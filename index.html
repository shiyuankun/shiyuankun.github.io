<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>彼格海德的笔记空间</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="python">
<meta property="og:type" content="website">
<meta property="og:title" content="彼格海德的笔记空间">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="彼格海德的笔记空间">
<meta property="og:description" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="彼格海德的笔记空间">
<meta name="twitter:description" content="python">
  
    <link rel="alternative" href="/atom.xml" title="彼格海德的笔记空间" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-62861406-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
<!-- Baidu Statistics -->
<script type="text/javascript">
    var _hmt = _hmt || [];
(function() {
 var hm = document.createElement("script");
 hm.src = "//hm.baidu.com/hm.js?77faa6f8da10ec42fb1c01f2947de873";
 var s = document.getElementsByTagName("script")[0]; 
 s.parentNode.insertBefore(hm, s);
 })();
</script>
<!-- End Baidu Statistics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">彼格海德的笔记空间</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">a notebook for python</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/index.html">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-learning-rust-part-XI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/23/learning-rust-part-XI/" class="article-date">
  <time datetime="2015-07-23T08:54:13.000Z" itemprop="datePublished">2015-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/23/learning-rust-part-XI/">rust学习笔记(十一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Deref_转换">Deref 转换</h2><p>在rust中，有一个特殊的trait，叫做Deref，他用来重载<em>号，这里</em>号的含义和c里面的一样用于取一个指针指的值。</p>
<pre><code><span class="keyword">use</span> std::ops::Deref;

<span class="keyword">struct</span> DerefExample&lt;T&gt; {
    value: T,
}

<span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> DerefExample&lt;T&gt; {
    <span class="keyword">type</span> <span class="title">Target</span> = T;

    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T {
        &amp;<span class="keyword">self</span>.value
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> x = DerefExample { value: <span class="string">'a'</span> };
    <span class="built_in">assert_eq!</span>(<span class="string">'a'</span>, *x);
}
</code></pre><p>这里重定义了*号的作用，所以就是取出封装的value。</p>
<h2 id="宏">宏</h2><p>宏的定义和c里面的概念差不多。甚至可以定义出递归宏，例如：</p>
<pre><code>macro_rules! write_html {
    (<span class="variable">$w</span><span class="symbol">:expr</span>, ) =&gt; (());

    (<span class="variable">$w</span><span class="symbol">:expr</span>, <span class="variable">$e</span><span class="symbol">:tt</span>) =&gt; (write!(<span class="variable">$w</span>, <span class="string">"{}"</span>, <span class="variable">$e</span>));

    (<span class="variable">$w</span><span class="symbol">:expr</span>, <span class="variable">$tag</span><span class="symbol">:ident</span> [ <span class="variable">$(</span><span class="variable">$inner</span><span class="symbol">:tt</span>)* ] <span class="variable">$(</span><span class="variable">$rest</span><span class="symbol">:tt</span>)*) =&gt; &lt;!--￼<span class="number">0</span>--&gt;;
}

<span class="keyword">fn</span> main() {
    <span class="keyword">use</span> <span class="symbol">std:</span><span class="symbol">:fmt</span><span class="symbol">:</span><span class="symbol">:Write</span>;
    let mut out = <span class="constant">String:</span><span class="symbol">:new</span>();

    write_html!(&amp;mut out,
        html[
            head[title[<span class="string">"Macros guide"</span>]]
            body[h1[<span class="string">"Macros are the best!"</span>]]
        ]);

    assert_eq!(out,
        <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>);
}
</code></pre><h2 id="Raw_Pointers">Raw Pointers</h2><p>rust拥有不少智能指针。但也可以使用原始指针，原始指针的定义就是<em>const T和</em>mut T<br>需要注意的是，<br>1.原始执政不保证指向内容有效。<br>2.没有自动清理<br>3.没有属主概念<br>4.没有生命周期概念<br>5.没有可变性保证。</p>
<p>这么申请一个原始指针</p>
<pre><code><span class="keyword">let</span> x = <span class="number">5</span>;
<span class="keyword">let</span> raw = &amp;x <span class="keyword">as</span> *<span class="keyword">const</span> <span class="keyword">i32</span>;

<span class="keyword">let</span> <span class="keyword">mut</span> y = <span class="number">10</span>;
<span class="keyword">let</span> raw_mut = &amp;<span class="keyword">mut</span> y <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="keyword">i32</span>;
</code></pre><p>但由于这种操作是没有刚才那些保证的，所以如果要取值必须使用unsafe</p>
<pre><code><span class="keyword">let</span> x = <span class="number">5</span>;
<span class="keyword">let</span> raw = &amp;x <span class="keyword">as</span> *<span class="keyword">const</span> <span class="keyword">i32</span>;

<span class="keyword">let</span> points_at = <span class="keyword">unsafe</span> { *raw };
</code></pre><p>rust离得原始指针主要用来给FFI用</p>
<h2 id="Unsafe">Unsafe</h2><p>unsafe主要是用来干一些编译器不让你干的事情<br>1.获取更改一个静态的可变变量<br>2.获取一个原始指针指向的值<br>3.调用一个不安全的函数</p>
<p>safe的保证可以看<a href="这里">https://doc.rust-lang.org/stable/book/unsafe.html</a></p>
<p>紧赶慢赶终于把rust教程看完了。很多地方没有细看，随手写了点笔记了解了一下rust的设计理念。接下去要实际拿一个项目测一下rust到底该如何做了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/23/learning-rust-part-XI/" data-id="cicfzby6u000v4zv49skc0i97" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-X" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/23/learning-rust-part-X/" class="article-date">
  <time datetime="2015-07-23T07:42:27.000Z" itemprop="datePublished">2015-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/23/learning-rust-part-X/">rust学习笔记(十)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Universal_Function_Call_Syntax">Universal Function Call Syntax</h2><p>有些时候函数可能会有相同的名字。例如：</p>
<pre><code><span class="keyword">trait</span> <span class="title">Foo</span> {
    <span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(&amp;<span class="keyword">self</span>);
}

<span class="keyword">trait</span> <span class="title">Bar</span> {
    <span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(&amp;<span class="keyword">self</span>);
}

<span class="keyword">struct</span> Baz;

<span class="keyword">impl</span> Foo <span class="keyword">for</span> Baz {
    <span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(&amp;<span class="keyword">self</span>) { <span class="built_in">println!</span>(<span class="string">"Baz’s impl of Foo"</span>); }
}

<span class="keyword">impl</span> Bar <span class="keyword">for</span> Baz {
    <span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(&amp;<span class="keyword">self</span>) { <span class="built_in">println!</span>(<span class="string">"Baz’s impl of Bar"</span>); }
}

<span class="keyword">let</span> b = Baz;
</code></pre><p>这时候如果调用b.f()就会报错。必须这样</p>
<pre><code><span class="rule"><span class="attribute">Foo</span>:<span class="value">:<span class="function">f</span>(&amp;b)</span></span>;
<span class="rule"><span class="attribute">Bar</span>:<span class="value">:<span class="function">f</span>(&amp;b)</span></span>;
</code></pre><p>才能正常执行。rust在执行b.f()是会自动借用b作为&amp;self，而这里不会，所以要手动将&amp;b传入。</p>
<h2 id="cates_and_modules">cates and modules</h2><p>在rust里，crate就是library package的同义词。每个crate都有一个根module，根module下面还有很多子module。</p>
<p>在src/lib.rs中这么写定义模块</p>
<pre><code><span class="operator">mod</span> <span class="keyword">english</span> {
    <span class="operator">mod</span> greetings {
    }

    <span class="operator">mod</span> farewells {
    }
}

<span class="operator">mod</span> japanese {
    <span class="operator">mod</span> greetings {
    }

    <span class="operator">mod</span> farewells {
    }
}
</code></pre><p>cargo会去src/<modname>.rs或者src/<modname>/mod.rs中去找相应模块。</modname></modname></p>
<h2 id="const_and_static">const and static</h2><pre><code><span class="tag">const</span> <span class="rule"><span class="attribute">N</span>:<span class="value"> i32=<span class="number">5</span></span></span>;
</code></pre><p>定义了一个寿命为永久的N，并且在rust中const没有地址，因为所有的N调用在编译时都会被替换为具体值。</p>
<pre><code><span class="tag">static</span> <span class="rule"><span class="attribute">N</span>:<span class="value"> i32=<span class="number">5</span></span></span>;
</code></pre><p>同样定义了一个永久寿命的N，但这个本质上是一个变量。</p>
<pre><code><span class="tag">static</span> <span class="tag">mut</span> <span class="rule"><span class="attribute">N</span>:<span class="value"> i32 = <span class="number">5</span></span></span>;
</code></pre><p>由于本身已经定义为static了，所以这样子可能导致一个线程读一个线程写，这是不安全的，所以要这么做只能放在unsafeblock里</p>
<pre><code><span class="keyword">unsafe</span> {
    N += <span class="number">1</span>;

    <span class="built_in">println!</span>(<span class="string">"N: {}"</span>, N);
}
</code></pre><p>所有static的类型必然是sync的。</p>
<h2 id="属性">属性</h2><p>通过#[test]来定义</p>
<h2 id="type">type</h2><p>type用来设定一个同义变量</p>
<pre><code><span class="keyword">type</span> Name = <span class="keyword">String</span>;
</code></pre><p>这个新的类型Name在函数调用上和String完全一样。</p>
<h2 id="不同类型间转换">不同类型间转换</h2><p>as可以做基本的转换</p>
<pre><code><span class="keyword">let</span> x: <span class="keyword">i32</span> = <span class="number">5</span>;
<span class="keyword">let</span> y = x <span class="keyword">as</span> <span class="keyword">i64</span>;
</code></pre><p>transmute可以不做检查直接转换</p>
<pre><code><span class="keyword">use</span> std::mem;
<span class="keyword">unsafe</span> {
    <span class="keyword">let</span> a = [<span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>];
    <span class="keyword">let</span> b = mem::transmute::&lt;[<span class="keyword">u8</span>; <span class="number">4</span>], <span class="keyword">u32</span>&gt;(a);
}
</code></pre><p>但还是会做一些基本的比如越界检查防止内存问题</p>
<h2 id="联合类型">联合类型</h2><p>例如对于一个图，你可能有Node Edge两种类型，但这样不美观，所以就可以用trait把两种类型联合起来</p>
<pre><code><span class="keyword">trait</span> Graph {
    <span class="keyword">type</span> N;
    <span class="keyword">type</span> E;

    fn has_edge(<span class="subst">&amp;</span><span class="built_in">self</span>, <span class="subst">&amp;</span><span class="built_in">Self</span><span class="tag">::N</span>, <span class="subst">&amp;</span><span class="built_in">Self</span><span class="tag">::N</span>) <span class="subst">-&gt; </span>bool;
    fn edges(<span class="subst">&amp;</span><span class="built_in">self</span>, <span class="subst">&amp;</span><span class="built_in">Self</span><span class="tag">::N</span>) <span class="subst">-&gt; </span>Vec<span class="subst">&lt;</span><span class="built_in">Self</span><span class="tag">::E</span><span class="subst">&gt;</span>;
    <span class="comment">// etc</span>
}
</code></pre><p>并实现相关的函数</p>
<pre><code><span class="keyword">struct</span> Node;

<span class="keyword">struct</span> Edge;

<span class="keyword">struct</span> MyGraph;

<span class="keyword">impl</span> Graph <span class="keyword">for</span> MyGraph {
    <span class="keyword">type</span> <span class="title">N</span> = Node;
    <span class="keyword">type</span> <span class="title">E</span> = Edge;

    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class="keyword">bool</span> {
        <span class="keyword">true</span>
    }

    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {
        Vec::new()
    }
}
</code></pre><h2 id="不定长类型">不定长类型</h2><p>大多数类型都有固定长度，但rust也允许使用动态长度的类型。但这里有一定的限制</p>
<p>1.只能通过指针操作unsized type, &amp;[T]可以但[T]不行<br>2.变量和参数不能有动态长度的类型<br>3.只有struct的最后一栏允许动态长度类型。enum不允许有动态长度类型</p>
<h2 id="操作符重载">操作符重载</h2><p>只要对一个类型实现相应的函数就能实现相应重载。</p>
<pre><code><span class="keyword">use</span> std::ops::Add;

<span class="preprocessor">#[derive(Debug)]</span>
<span class="keyword">struct</span> Point {
    x: <span class="keyword">i32</span>,
    y: <span class="keyword">i32</span>,
}

<span class="keyword">impl</span> Add <span class="keyword">for</span> Point {
    <span class="keyword">type</span> <span class="title">Output</span> = Point;

    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, other: Point) -&gt; Point {
        Point { x: <span class="keyword">self</span>.x + other.x, y: <span class="keyword">self</span>.y + other.y }
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> p1 = Point { x: <span class="number">1</span>, y: <span class="number">0</span> };
    <span class="keyword">let</span> p2 = Point { x: <span class="number">2</span>, y: <span class="number">3</span> };

    <span class="keyword">let</span> p3 = p1 + p2;

    <span class="built_in">println!</span>(<span class="string">"{:?}"</span>, p3);
}
</code></pre><p>这些允许重载的函数可以在std::ops中找到</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/23/learning-rust-part-X/" data-id="cicfzby6w000y4zv46eihb7ac" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-IX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/23/learning-rust-part-IX/" class="article-date">
  <time datetime="2015-07-23T06:21:13.000Z" itemprop="datePublished">2015-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/23/learning-rust-part-IX/">rust学习笔记(九)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>感觉好累，休息了一天，连椭圆机都没练，感觉今天终于缓过来了，继续学习。</p>
<h2 id="Trait_对象">Trait 对象</h2><p>当代码处理多态(polymorphism)的时候，需要有一个机制来决定到底执行哪个版本的代码。这通常叫做调度(dispatch)。调度的方式一般有两种，静态和动态。rust倾向于静态调度，但也支持动态调度。</p>
<p>例如，我们定义一个trait，并对u8和string实现一个方法</p>
<pre><code>trait <span class="type">Foo</span> {
    fn <span class="keyword">method</span>(&amp;self) -&gt; <span class="type">String</span>;
}

impl <span class="type">Foo</span> <span class="keyword">for</span> u8 {
    fn <span class="keyword">method</span>(&amp;self) -&gt; <span class="type">String</span> { format!(<span class="string">"u8: {}"</span>, *self) }
}

impl <span class="type">Foo</span> <span class="keyword">for</span> <span class="type">String</span> {
    fn <span class="keyword">method</span>(&amp;self) -&gt; <span class="type">String</span> { format!(<span class="string">"string: {}"</span>, *self) }
}
</code></pre><p>这时候静态的调度就可以通过trait bounds实现</p>
<pre><code>fn do_something&lt;T: <span class="type">Foo</span>&gt;(x: T) {
    x.<span class="keyword">method</span>();
}

fn main() {
    <span class="keyword">let</span> x = <span class="number">5u8</span>;
    <span class="keyword">let</span> y = <span class="string">"Hello"</span>.to_string();

    do_something(x);
    do_something(y);
}
</code></pre><p>rust是通过单态(monomorphization)来实现静态调度的。也就是说，编译之后为每一个T类型产生一个do_something_T这样的函数，并且替换掉每一个do_something的调用为相应类型的调用。<br>这样做的好处是可以将函数内联(inline)，这样可以让程序跑得更快，但也有坏处，会产生过多的函数。另外没有充分优化过得的编译器也会让某些inline函数跑得更慢。</p>
<h2 id="dynamic_dispatch">dynamic dispatch</h2><p>rust通过特点对象(trait objects)来实现动态调度(dynamic dispatch)。trait objects的使用很简单，就是&amp;Foo 或者 Box<foo>。在调用时使用(&amp;x as &amp;Foo)转换，或者(&amp;x作为函数参数)强制转换就可以使用trait objects来实现动态调度了。例如：<br>普通转换</foo></p>
<pre><code>fn do_something(x: &amp;<span class="type">Foo</span>) {
    x.<span class="keyword">method</span>();
}

fn main() {
    <span class="keyword">let</span> x = <span class="number">5u8</span>;
    do_something(&amp;x <span class="keyword">as</span> &amp;<span class="type">Foo</span>);
}
</code></pre><p>强制转换</p>
<pre><code>fn do_something(x: &amp;<span class="type">Foo</span>) {
    x.<span class="keyword">method</span>();
}

fn main() {
    <span class="keyword">let</span> x = <span class="string">"Hello"</span>.to_string();
    do_something(&amp;x);
}
</code></pre><p>这种转换会使编译器失去原始类型的信息，所以也可以认为是”type erasure”</p>
<h2 id="closures">closures</h2><p>rust支持闭包(closures)，也就是有函数环境的匿名函数。rust闭包这样子实现</p>
<pre><code><span class="keyword">let</span> <span class="variable">plus_one =</span> |x: i32| x + <span class="number">1</span>;
</code></pre><p>这样子就创建了一个闭包，闭包的参数在管道符中间，然后跟着表达式就是闭包的函数体。由于{}可以视为一个表达式，所以也可以用大括号将多行代码扩起来组成一个复杂点的闭包，这点比python好太多。</p>
<pre><code><span class="keyword">let</span> plus_two = |x| {
    <span class="keyword">let</span> mut <span class="literal">result</span>: i32 = x;

    <span class="literal">result</span> += <span class="number">1</span>;
    <span class="literal">result</span> += <span class="number">1</span>;

    <span class="literal">result</span>
};
</code></pre><p>闭包也可以用类型指定返回值，</p>
<pre><code><span class="keyword">let</span> plus_one = |x: <span class="keyword">i32</span>| -&gt; <span class="keyword">i32</span> { x + <span class="number">1</span> };
</code></pre><p>但一般为了简洁不这么做</p>
<p>在python中，闭包的内部环境处理的并不好，如果引用了外部变量，那匿名函数的内部引用会随这外部变量的改变而改变，这点很坑。<br>rust部分解决了这个问题。</p>
<pre><code><span class="keyword">let</span> mut <span class="variable">num =</span> <span class="number">5</span>;
<span class="keyword">let</span> <span class="variable">plus_num =</span> |x: i32| x + num;

<span class="keyword">let</span> <span class="variable">y =</span> &amp;mut num;
</code></pre><p>这样是错误的，编译器会告诉你在定义plus_num的时候num被immutable引用了，所以y=&amp;mut num就报错了。<br>要这么做只能让闭包在他自己的作用域中，执行完以后消失</p>
<pre><code><span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;
{
    <span class="keyword">let</span> plus_num = |x: <span class="keyword">i32</span>| x + num;

} <span class="comment">// plus_num 离开作用域就消失了。</span>

<span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> num;
</code></pre><h2 id="move闭包">move闭包</h2><pre><code><span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;

{ 
    <span class="keyword">let</span> <span class="keyword">mut</span> add_num = |x: <span class="keyword">i32</span>| num += x;

    add_num(<span class="number">5</span>);
}

<span class="built_in">assert_eq!</span>(<span class="number">10</span>, num);<span class="comment">//结果是10</span>


<span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;

{ 
    <span class="keyword">let</span> <span class="keyword">mut</span> add_num = move |x: <span class="keyword">i32</span>| num += x;

    add_num(<span class="number">5</span>);
}

<span class="built_in">assert_eq!</span>(<span class="number">5</span>, num);<span class="comment">//结果是5</span>
</code></pre><p>所以在定义闭包时使用move就是对所使用的外部变量做了一个copy，即使改变了，离开了作用域还是原来的值。</p>
<h2 id="closure_实现方法">closure 实现方法</h2><p>同其他语言不一样，rust里闭包的实现其是靠的就是trait objects。</p>
<pre><code>pub <span class="keyword">trait</span> Fn<span class="subst">&lt;</span>Args<span class="subst">&gt;</span> : FnMut<span class="subst">&lt;</span>Args<span class="subst">&gt;</span> {
    extern <span class="string">"rust-call"</span> fn call(<span class="subst">&amp;</span><span class="built_in">self</span>, args: Args) <span class="subst">-&gt; </span><span class="built_in">Self</span><span class="tag">::Output</span>;
}

pub <span class="keyword">trait</span> FnMut<span class="subst">&lt;</span>Args<span class="subst">&gt;</span> : FnOnce<span class="subst">&lt;</span>Args<span class="subst">&gt;</span> {
    extern <span class="string">"rust-call"</span> fn call_mut(<span class="subst">&amp;</span>mut <span class="built_in">self</span>, args: Args) <span class="subst">-&gt; </span><span class="built_in">Self</span><span class="tag">::Output</span>;
}

pub <span class="keyword">trait</span> FnOnce<span class="subst">&lt;</span>Args<span class="subst">&gt;</span> {
    <span class="keyword">type</span> Output;

    extern <span class="string">"rust-call"</span> fn call_once(<span class="built_in">self</span>, args: Args) <span class="subst">-&gt; </span><span class="built_in">Self</span><span class="tag">::Output</span>;
}
</code></pre><p>在rust内部，所有的闭包都是以上这三个trait objects的重载</p>
<h2 id="将闭包作为参数">将闭包作为参数</h2><p>看懂了闭包的实现本质是trait objects，我们就可以看看怎么把闭包作为参数传递进别的函数中。</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">call_with_one</span></span>&lt;F&gt;(some_closure: F) -&gt; <span class="keyword">i32</span>
    where F : Fn(<span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> {

    some_closure(<span class="number">1</span>)
}

<span class="keyword">let</span> answer = call_with_one(|x| x + <span class="number">2</span>);

<span class="built_in">assert_eq!</span>(<span class="number">3</span>, answer);
</code></pre><p>这里是一个例子，在call_with_one的调用时定义了一个匿名函数，然后在定义call_with_one里，将参数定义为类型F，返回值为i32，然后接着一行where F: Fn(i32)-&gt;i32)的意思就是F这个类型其实是Fn(i32)-&gt;i32，Fn就是上一节第一个闭包。</p>
<h2 id="返回闭包">返回闭包</h2><p>能传入闭包，那能返回闭包吗？</p>
<p>能！但不能像传入闭包一样那样定义一个传出的函数，然后类型是Fn。1.是生命周期的缘故，所有内部定义的函数他的生命都不会长过函数本身，这个可以用’static定义返回值类型来避开。2.这个就比较麻烦，应为在rust编译器里，闭包直接有一个类型叫闭包，并不是Fn….3.由于在函数中定义闭包很容易以来函数内部的变量，这些变量的寿命都很短，所以rust为了避免问题就将所有的闭包定义为一个新的闭包并且没有static生命。当然这也不难解决</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">factory</span></span>() -&gt; Box&lt;Fn(<span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span>&gt; {<span class="comment">//Fn就是为了定义闭包，Box为了将闭包类型转换</span>
    <span class="keyword">let</span> num = <span class="number">5</span>;

    Box::new(move |x| x + num)<span class="comment">//move 为了将num做一份复制到闭包中，避免num本身的生命周期过短的问题</span>
}
<span class="keyword">let</span> f = factory();

<span class="keyword">let</span> answer = f(<span class="number">1</span>);
<span class="built_in">assert_eq!</span>(<span class="number">6</span>, answer);
</code></pre><p>内心不住的咆哮(我要休假！去海边！)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/23/learning-rust-part-IX/" data-id="cicfzby7500184zv4dltnct53" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-VIII" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/21/learning-rust-part-VIII/" class="article-date">
  <time datetime="2015-07-21T08:09:47.000Z" itemprop="datePublished">2015-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/21/learning-rust-part-VIII/">rust学习笔记(八)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Vector">Vector</h2><p>这个应该翻译成向量，因为教程自己都说了<br>A ‘vector’ is a dynamic or ‘growable’ array<br>定义和遍历向量的方法之前的笔记里已经提到过，相当简单</p>
<pre><code><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

<span class="keyword">for</span> i <span class="keyword">in</span> &amp;v {
    <span class="built_in">println!</span>(<span class="string">"A reference to {}"</span>, i);
}

<span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v {
    <span class="built_in">println!</span>(<span class="string">"A mutable reference to {}"</span>, i);
}

<span class="keyword">for</span> i <span class="keyword">in</span> v {
    <span class="built_in">println!</span>(<span class="string">"Take ownership of the vector and its element {}"</span>, i);
}
</code></pre><h2 id="字符串">字符串</h2><p>有意思的是，在rust里字符串有两种类型，一种叫做&amp;str(注意那个&amp;，说明是个指针？)一种叫做String。对于&amp;str，其实他的默认生命周期是’static的，所以会永久保存直到程序结束。并且&amp;str的长度固定，不能被改变。<br>而String的长度是可变的，保证是UTF8，String通常是通过&amp;str的to_string()方法创造的。String能通过加一个&amp;强制转换成&amp;str。</p>
<pre><code><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="string">"Hello"</span>.to_string(); 
<span class="built_in">println!</span>(<span class="string">"{}"</span>, s);

s.push_str(<span class="string">", world."</span>);
<span class="built_in">println!</span>(<span class="string">"{}"</span>, s);

<span class="function"><span class="keyword">fn</span> <span class="title">takes_slice</span></span>(slice: &amp;<span class="keyword">str</span>) {
    <span class="built_in">println!</span>(<span class="string">"Got: {}"</span>, slice);
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> s = <span class="string">"Hello"</span>.to_string();
    takes_slice(&amp;s);
}
</code></pre><h2 id="索引">索引</h2><p>通常，应为字符串是utf-8的，所以字符串不支持索引(&amp;str也不支持)</p>
<pre><code><span class="keyword">let</span> s = <span class="string">"hello"</span>;

<span class="built_in">println!</span>(<span class="string">"The first letter of s is {}"</span>, s[<span class="number">0</span>]);<span class="comment">//报错</span>
</code></pre><p>但是可以通过别的方法遍历</p>
<pre><code><span class="keyword">let</span> s = <span class="string">"关关雎鸠，在河之洲。窈窕淑女，君子好逑。"</span>;
<span class="keyword">for</span> b <span class="keyword">in</span> s.as_bytes(){
    <span class="built_in">print</span>!(<span class="string">"{}, "</span>,b);
}

<span class="built_in">println</span>!(<span class="string">""</span>);

<span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> s.chars(){
    <span class="built_in">print</span>!(<span class="string">"{}, "</span>,<span class="built_in">c</span>);
}
<span class="built_in">println</span>!(<span class="string">""</span>);
</code></pre><p>以及索引</p>
<pre><code><span class="keyword">let</span> <span class="variable">guan =</span> s.chars().nth(<span class="number">1</span>);
</code></pre><h2 id="字符连接">字符连接</h2><p>rust的字符连接稍微复杂点，String后可以加&amp;str来连接，但是如果两个String，第二个String必须用&amp;强制转换为&amp;str，如果是两个&amp;str，第一个必须用.to_string()转化为String</p>
<h2 id="通用类型">通用类型</h2><p>rust支持T作为通用类型来支持多种类型的函数，枚举等等。</p>
<pre><code><span class="keyword">fn</span> takes_anything&lt;<span class="constant">T&gt;</span>(<span class="symbol">x:</span> <span class="constant">T)</span> {
    <span class="regexp">//</span> <span class="keyword">do</span> something with x
}
</code></pre><p>也可以多个通用类型，这点和Haskell很像</p>
<pre><code>fn takes_two_things&lt;T, U&gt;(<span class="string">x:</span> T, <span class="string">y:</span> U) {
    <span class="comment">// ...</span>
}
</code></pre><h2 id="Trait">Trait</h2><p>Rust里的trait类似于scala里的trait，有点像java里的抽象类，规定了这个结构必须有的方法，然后impl去实现就行。trait的好处是可以给不同类型规定必须实现的方法，例如</p>
<pre><code><span class="keyword">struct</span> Circle {
    x: <span class="keyword">f64</span>,
    y: <span class="keyword">f64</span>,
    radius: <span class="keyword">f64</span>,
}

<span class="keyword">trait</span> <span class="title">HasArea</span> {
    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">f64</span>;
}

<span class="keyword">impl</span> HasArea <span class="keyword">for</span> Circle {
    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">f64</span> {
        std::f64::consts::PI * (<span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius)
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">print_area</span></span>&lt;T&gt;(shape: T) {
    <span class="built_in">println!</span>(<span class="string">"This shape has an area of {}"</span>, shape.area());
}
</code></pre><p>这样是会报错的，因为T这个匿名类型没有实现area这个方法。但是这样指定就没问题：</p>
<pre><code><span class="tag">fn</span> <span class="tag">print_area</span>&lt;<span class="rule"><span class="attribute">T</span>:<span class="value"> HasArea&gt;(shape: T) {
    println!(<span class="string">"This shape has an area of {}"</span>, shape.<span class="function">area</span>())</span></span>;
}
</code></pre><p>这是因为在函数名后的尖括号里规定了T必须实现HasArea这个trait规定的所有函数(也就是必须有area这个函数)，如果要指定多个trait，需要用加号</p>
<pre><code><span class="keyword">use</span> std::fmt::Debug;

<span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;T: Clone + Debug&gt;(x: T) {
    x.clone();
    <span class="built_in">println!</span>(<span class="string">"{:?}"</span>, x);
}
</code></pre><h2 id="Where">Where</h2><p>在写Trait的时候，如果变量类型一多，很容易比较乱，rust利用where，将整个trait后置，变得易于阅读。</p>
<pre><code><span class="keyword">use</span> <span class="title">std</span>::<span class="title">fmt</span>::<span class="title">Debug</span>;

fn bar&lt;T, K&gt;(x: T, y: K)
    where T: <span class="keyword">Clone</span>,
          K: <span class="keyword">Clone</span> + Debug {

    x.<span class="keyword">clone</span>();
    y.<span class="keyword">clone</span>();
    println!(<span class="string">"{:?}"</span>, y);
}
</code></pre><p>默认方法</p>
<p>在trait中，同样可以实现某个方法，这样所有指定了该trait的类型都会自动拥有这个方法。</p>
<pre><code><span class="keyword">trait</span> <span class="title">Foo</span> {
    <span class="function"><span class="keyword">fn</span> <span class="title">bar</span></span>(&amp;<span class="keyword">self</span>);

    <span class="function"><span class="keyword">fn</span> <span class="title">baz</span></span>(&amp;<span class="keyword">self</span>) { <span class="built_in">println!</span>(<span class="string">"We called baz."</span>); }
}
</code></pre><p>继承</p>
<p>trait也可以继承，也就是说实现trait a必须实现trait b。</p>
<pre><code><span class="class"><span class="keyword">trait</span> <span class="title">Foo</span> </span>{
    fn foo(&amp;self);
}

<span class="class"><span class="keyword">trait</span> <span class="title">FooBar</span> : <span class="typename">Foo {</span></span>
    fn foobar(&amp;self);
}
</code></pre><h2 id="Drop">Drop</h2><p>drop是rust里得一个特殊的trait，他的作用居然是在变量离开作用域的时候执行。通常这是用来做一些清理工作的。</p>
<pre><code><span class="keyword">struct</span> Firework {
    strength: <span class="keyword">i32</span>,
}

<span class="keyword">impl</span> Drop <span class="keyword">for</span> Firework {
    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) {
        <span class="built_in">println!</span>(<span class="string">"BOOM times {}!!!"</span>, <span class="keyword">self</span>.strength);
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> firecracker = Firework { strength: <span class="number">1</span> };
    <span class="keyword">let</span> tnt = Firework { strength: <span class="number">100</span> };
    <span class="built_in">println!</span>(<span class="string">"test"</span>);
}
</code></pre><p>这段代码的执行结果是</p>
<pre><code><span class="function_or_atom">test</span>
<span class="variable">BOOM</span> <span class="function_or_atom">times</span> <span class="number">100</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
<span class="variable">BOOM</span> <span class="function_or_atom">times</span> <span class="number">1</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
</code></pre><p>也就是说先执行了println!(“test”)，然后才执行了每个变量的drop方法。并且这是一个先进后出的栈。</p>
<h2 id="if_let">if let</h2><p>if let 主要是用来做一些模式匹配的工作，例如</p>
<pre><code>match option <span class="list">{
    Some(x) =&gt; { foo(x) }</span>,
    <span class="keyword">None</span> =&gt; <span class="list">{}</span>,
}
</code></pre><p>这么一个模式匹配，如果用if语句来做可以这么做。</p>
<pre><code><span class="keyword">if</span> <span class="built_in">option</span>.is_some<span class="literal">()</span> {
    <span class="keyword">let</span> x = <span class="built_in">option</span>.unwrap<span class="literal">()</span>;
    foo(x);
}
</code></pre><p>但是用if let可以更加简介</p>
<pre><code><span class="function"><span class="keyword">if</span> <span class="keyword">let</span> <span class="title">Some</span><span class="params">(x)</span> </span>= option {
    foo(x);
}
</code></pre><p>当模式不匹配的时候还可以用else</p>
<pre><code><span class="keyword">if</span> <span class="keyword">let</span> <span class="type">Some</span>(x) = <span class="built_in">option</span> {
    foo(x);
} <span class="keyword">else</span> {
    bar<span class="literal">()</span>;
}
</code></pre><h2 id="while_let">while let</h2><p>和if let一样，不同的是不断重复匹配</p>
<pre><code><span class="function"><span class="keyword">while</span> <span class="keyword">let</span> <span class="title">Some</span><span class="params">(x)</span> </span>= option {
    println!(<span class="string">"{}"</span>, x);
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/21/learning-rust-part-VIII/" data-id="cicfzby6y00104zv4rpu8jvhn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-VII" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/21/learning-rust-part-VII/" class="article-date">
  <time datetime="2015-07-21T07:33:12.000Z" itemprop="datePublished">2015-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/21/learning-rust-part-VII/">rust学习笔记(七)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="match">match</h2><p>匹配是一个很好用的东西，在haskell中非常常见，要注意，匹配的时候必须全覆盖，加一个默认条件就能全覆盖，例如：</p>
<pre><code><span class="keyword">let</span> x = <span class="number">5</span>;

<span class="keyword">let</span> number = <span class="keyword">match</span> x {
    <span class="number">1</span> =&gt; <span class="string">"one"</span>,
    <span class="number">2</span> =&gt; <span class="string">"two"</span>,
    <span class="number">3</span> =&gt; <span class="string">"three"</span>,
    <span class="number">4</span> =&gt; <span class="string">"four"</span>,
    <span class="number">5</span> =&gt; <span class="string">"five"</span>,
    _ =&gt; <span class="string">"something else"</span>,
};
</code></pre><p>这个_就是默认条件。但匹配并不是用在这里，更多的用在枚举类型上，例如</p>
<pre><code><span class="keyword">enum</span> <span class="title">Message</span> {
    Quit,
    ChangeColor(<span class="keyword">i32</span>, <span class="keyword">i32</span>, <span class="keyword">i32</span>),
    Move { x: <span class="keyword">i32</span>, y: <span class="keyword">i32</span> },
    Write(String),
}

<span class="function"><span class="keyword">fn</span> <span class="title">quit</span></span>() { <span class="comment">/* ... */</span> }
<span class="function"><span class="keyword">fn</span> <span class="title">change_color</span></span>(r: <span class="keyword">i32</span>, g: <span class="keyword">i32</span>, b: <span class="keyword">i32</span>) { <span class="comment">/* ... */</span> }
<span class="function"><span class="keyword">fn</span> <span class="title">move_cursor</span></span>(x: <span class="keyword">i32</span>, y: <span class="keyword">i32</span>) { <span class="comment">/* ... */</span> }

<span class="function"><span class="keyword">fn</span> <span class="title">process_message</span></span>(msg: Message) {
    <span class="keyword">match</span> msg {
        Message::Quit =&gt; quit(),
        Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b),
        Message::Move { x: x, y: y } =&gt; move_cursor(x, y),
        Message::Write(s) =&gt; <span class="built_in">println!</span>(<span class="string">"{}"</span>, s),
    };
}
</code></pre><p>这里就可以根据枚举类型里不同的各种类型做各种匹配。</p>
<p>也可以做多模式匹配和区域匹配</p>
<pre><code><span class="keyword">let</span> x = <span class="number">1</span>;

<span class="keyword">match</span> x {
    <span class="number">1</span> | <span class="number">2</span> =&gt; println!(<span class="string">"one or two"</span>),
    <span class="number">3</span> ... <span class="number">5</span> =&gt; println!(<span class="string">"three"</span>),
    _ =&gt; println!(<span class="string">"anything"</span>),
}
</code></pre><p>在匹配模式比较复杂的时候还可以使用绑定</p>
<pre><code><span class="comment">#[derive(Debug)]</span>
struct <span class="type">Person</span> {
    name: <span class="type">Option</span>&lt;<span class="type">String</span>&gt;,
}

<span class="keyword">let</span> name = <span class="string">"Steve"</span>.to_string();
<span class="keyword">let</span> mut x: <span class="type">Option</span>&lt;<span class="type">Person</span>&gt; = <span class="type">Some</span>(<span class="type">Person</span> { name: <span class="type">Some</span>(name) });
match x {
    <span class="type">Some</span>(<span class="type">Person</span> { name: <span class="keyword">ref</span> a @ <span class="type">Some</span>(_), .. }) =&gt; println!(<span class="string">"{:?}"</span>, a),
    _ =&gt; {}
}
</code></pre><p>得到相应值，在多模式匹配的时候必须确保每个部分都有绑定</p>
<pre><code><span class="keyword">let</span> x = <span class="number">5</span>;

match x {
    <span class="literal">e</span> @ <span class="number">1</span> ... <span class="number">5</span> | <span class="literal">e</span> @ <span class="number">8</span> ... <span class="number">10</span> =&gt; println!(<span class="string">"got a range element {}"</span>, <span class="literal">e</span>),
    _ =&gt; println!(<span class="string">"anything"</span>),
}
</code></pre><p>还可以忽略掉具体值</p>
<pre><code><span class="keyword">enum</span> <span class="title">OptionalInt</span> {
    Value(<span class="keyword">i32</span>),
    Missing,
}

<span class="keyword">let</span> x = OptionalInt::Value(<span class="number">5</span>);

<span class="keyword">match</span> x {
    OptionalInt::Value(..) =&gt; <span class="built_in">println!</span>(<span class="string">"Got an int!"</span>),
    OptionalInt::Missing =&gt; <span class="built_in">println!</span>(<span class="string">"No such luck."</span>),
}
</code></pre><p>或者使用if来匹配</p>
<pre><code><span class="keyword">enum</span> <span class="title">OptionalInt</span> {
    Value(<span class="keyword">i32</span>),
    Missing,
}

<span class="keyword">let</span> x = OptionalInt::Value(<span class="number">5</span>);

<span class="keyword">match</span> x {
    OptionalInt::Value(i) <span class="keyword">if</span> i &gt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Got an int bigger than five!"</span>),
    OptionalInt::Value(..) =&gt; <span class="built_in">println!</span>(<span class="string">"Got an int!"</span>),
    OptionalInt::Missing =&gt; <span class="built_in">println!</span>(<span class="string">"No such luck."</span>),
}
</code></pre><p>匹配的时候与haskell一样，也可以解包具体值</p>
<pre><code><span class="keyword">struct</span> Point {
    x: <span class="keyword">i32</span>,
    y: <span class="keyword">i32</span>,
}

<span class="keyword">let</span> origin = Point { x: <span class="number">0</span>, y: <span class="number">0</span> };

<span class="keyword">match</span> origin {
    Point { x: x, .. } =&gt; <span class="built_in">println!</span>(<span class="string">"x is {}"</span>, x),
}
</code></pre><h2 id="方法">方法</h2><p>对于rust里的结构体，可以通过impl来实现这个结构体的方法，例如</p>
<pre><code><span class="keyword">struct</span> Circle {
    x: <span class="keyword">f64</span>,
    y: <span class="keyword">f64</span>,
    radius: <span class="keyword">f64</span>,
}

<span class="keyword">impl</span> Circle {
    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">f64</span> {
        std::f64::consts::PI * (<span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius)
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> c = Circle { x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, radius: <span class="number">2.0</span> };
    <span class="built_in">println!</span>(<span class="string">"{}"</span>, c.area());
}
</code></pre><p>如果要做到foo.bar().baz()这样的调用方式，bar()的返回类型必须有baz这个函数</p>
<p>在指定impl函数的时候如果不加self参数，就成为了联合函数</p>
<pre><code><span class="keyword">struct</span> Circle {
    x: <span class="keyword">f64</span>,
    y: <span class="keyword">f64</span>,
    radius: <span class="keyword">f64</span>,
}

<span class="keyword">impl</span> Circle {
    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: <span class="keyword">f64</span>, y: <span class="keyword">f64</span>, radius: <span class="keyword">f64</span>) -&gt; Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> c = Circle::new(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">2.0</span>);
}
</code></pre><p>rust没有python那样的默认参数，所以在定义类似函数时稍微麻烦点，例如</p>
<pre><code><span class="keyword">struct</span> Circle {
    x: <span class="keyword">f64</span>,
    y: <span class="keyword">f64</span>,
    radius: <span class="keyword">f64</span>,
}

<span class="keyword">impl</span> Circle {
    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">f64</span> {
        std::f64::consts::PI * (<span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius)
    }
}

<span class="keyword">struct</span> CircleBuilder {
    x: <span class="keyword">f64</span>,
    y: <span class="keyword">f64</span>,
    radius: <span class="keyword">f64</span>,
}

<span class="keyword">impl</span> CircleBuilder {
    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; CircleBuilder {
        CircleBuilder { x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, radius: <span class="number">1.0</span>, }
    }

    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, coordinate: <span class="keyword">f64</span>) -&gt; &amp;<span class="keyword">mut</span> CircleBuilder {
        <span class="keyword">self</span>.x = coordinate;
        <span class="keyword">self</span>
    }

    <span class="function"><span class="keyword">fn</span> <span class="title">y</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, coordinate: <span class="keyword">f64</span>) -&gt; &amp;<span class="keyword">mut</span> CircleBuilder {
        <span class="keyword">self</span>.y = coordinate;
        <span class="keyword">self</span>
    }

    <span class="function"><span class="keyword">fn</span> <span class="title">radius</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, radius: <span class="keyword">f64</span>) -&gt; &amp;<span class="keyword">mut</span> CircleBuilder {
        <span class="keyword">self</span>.radius = radius;
        <span class="keyword">self</span>
    }

    <span class="function"><span class="keyword">fn</span> <span class="title">finalize</span></span>(&amp;<span class="keyword">self</span>) -&gt; Circle {
        Circle { x: <span class="keyword">self</span>.x, y: <span class="keyword">self</span>.y, radius: <span class="keyword">self</span>.radius }
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> c = CircleBuilder::new()
                .x(<span class="number">1.0</span>)
                .y(<span class="number">2.0</span>)
                .radius(<span class="number">2.0</span>)
                .finalize();

    <span class="built_in">println!</span>(<span class="string">"area: {}"</span>, c.area());
    <span class="built_in">println!</span>(<span class="string">"x: {}"</span>, c.x);
    <span class="built_in">println!</span>(<span class="string">"y: {}"</span>, c.y);
}
</code></pre><p>在这个例子里，首先是定义了一个CircleBuilder，然后不断将需要改变的参数累积，最后形成一个circle类</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/21/learning-rust-part-VII/" data-id="cicfzby6z00124zv4a6d4s2ri" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-VI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/21/learning-rust-part-VI/" class="article-date">
  <time datetime="2015-07-21T06:56:38.000Z" itemprop="datePublished">2015-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/21/learning-rust-part-VI/">rust学习笔记(六)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="可变性(Mutability)">可变性(Mutability)</h2><p>rust的可变性已经提到过很多了，差不多就是这样子</p>
<pre><code><span class="keyword">let</span> mut <span class="variable">x =</span> <span class="number">5</span>;
<span class="keyword">let</span> <span class="variable">y =</span> &amp;mut x;
</code></pre><p>但这次要多一个概念，即内部和外部可变性。</p>
<p>我们在讨论可变性的时候，其实是在讨论外部可变性，比如</p>
<pre><code><span class="keyword">use</span> std::sync::Arc;

<span class="keyword">let</span> x = Arc::new(<span class="number">5</span>);
<span class="keyword">let</span> y = x.clone();
</code></pre><p>这样是可以的。因为符合了以下原则</p>
<ol>
<li>对一个资源的一个或者多个引用(&amp;T)</li>
<li>同时只能有一个可变引用(&amp;mut T)</li>
</ol>
<p>这就是为什么上面那段代码可行，因为任何时候T.clone()给出的都是T的不可变引用(&amp;T)</p>
<p>但下面这段就不行了</p>
<pre><code><span class="keyword">use</span> std::cell::RefCell;
<span class="keyword">let</span> x = RefCell::new(<span class="number">42</span>);
<span class="keyword">let</span> y = x.borrow_mut();
<span class="keyword">let</span> z = x.borrow_mut();
</code></pre><p>这里，y已经借出了一个&amp;mut T，所以z再借出就报错panic了。</p>
<p>由于可变性是借(&amp;mut)或者绑定(let mut)的一个属性，所以对于结构体不存在某些属性可变某些属性不可变。</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>{
    x: <span class="built_in">i32</span>,
    mut y: <span class="built_in">i32</span>,
}
</code></pre><p>这是错的，只能这么操作</p>
<pre><code><span class="keyword">struct</span> Point {
    x: <span class="keyword">i32</span>,
    y: <span class="keyword">i32</span>,
}
<span class="keyword">let</span> <span class="keyword">mut</span> a = Point { x: <span class="number">5</span>, y: <span class="number">6</span> };
a.x = <span class="number">10</span>;
<span class="keyword">let</span> b = Point { x: <span class="number">5</span>, y: <span class="number">6</span>};
b.x = <span class="number">10</span>;<span class="comment">//这里也错了，因为b的绑定是不可变的</span>
</code></pre><p>当然，可以利用Cell<t>特性模拟可变</t></p>
<pre><code><span class="keyword">use</span> std::cell::Cell;

<span class="keyword">struct</span> Point {
    x: <span class="keyword">i32</span>,
    y: Cell&lt;<span class="keyword">i32</span>&gt;,
}

<span class="keyword">let</span> point = Point { x: <span class="number">5</span>, y: Cell::new(<span class="number">6</span>) };

point.y.set(<span class="number">7</span>);

<span class="built_in">println!</span>(<span class="string">"y: {:?}"</span>, point.y);
</code></pre><h2 id="结构体">结构体</h2><p>结构体的定义和c差不多。</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>{
    x: <span class="built_in">i32</span>,
    y: <span class="built_in">i32</span>,
}
</code></pre><p>当你要更新一个结构体的时候，多了一种方法..</p>
<pre><code><span class="keyword">struct</span> Point3d {
    x: <span class="keyword">i32</span>,
    y: <span class="keyword">i32</span>,
    z: <span class="keyword">i32</span>,
}

<span class="keyword">let</span> <span class="keyword">mut</span> point = Point3d { x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> };
point = Point3d { y: <span class="number">1</span>, .. point };
</code></pre><p>这样point中除y以外的数值都会从另一个复制过来</p>
<p>Tuple structs<br>这个定义类似于tuple和struct结合体</p>
<pre><code><span class="keyword">struct</span> Color(<span class="keyword">i32</span>, <span class="keyword">i32</span>, <span class="keyword">i32</span>);
<span class="keyword">struct</span> Point(<span class="keyword">i32</span>, <span class="keyword">i32</span>, <span class="keyword">i32</span>);

<span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
</code></pre><p>但不推荐这么写，因为没有变量名字。</p>
<p>但有的时候有奇效，比如</p>
<pre><code>struct Inches<span class="list">(<span class="keyword">i32</span>)</span><span class="comment">;</span>

let length = Inches<span class="list">(<span class="number">10</span>)</span><span class="comment">;</span>

let Inches<span class="list">(<span class="keyword">integer_length</span>)</span> = length<span class="comment">;</span>
println!<span class="list">(<span class="string">"length is {} inches"</span>, integer_length)</span><span class="comment">;</span>
</code></pre><p>这样可以从tuple struct解包出一个数值，有点像python的unpack。</p>
<h2 id="Enums">Enums</h2><p>枚举是一个常见的东西，就不细说了<br>差不多就是把不同种类的变量类型打包成一个类型，这个类型的数据有各种变量类型的可能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/21/learning-rust-part-VI/" data-id="cicfzby7100144zv4l2irgynb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-V" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/20/learning-rust-part-V/" class="article-date">
  <time datetime="2015-07-20T07:32:11.000Z" itemprop="datePublished">2015-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/20/learning-rust-part-V/">rust学习笔记(五)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="所有权">所有权</h2><p>rust里有数据所有权这个概念</p>
<pre><code><span class="keyword">let</span> <span class="variable">v =</span> vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="keyword">let</span> <span class="variable">v2 =</span> v;

println!(<span class="string">"v[0] is: {}"</span>, v[<span class="number">0</span>]);
</code></pre><p>这里会报错，因为v本质是一个指针，指向数据的指针，v2被赋值以后也是。这样就发生数据竞争，所以v这个引用不再可用。</p>
<p>并且，在调用函数时也会发生类似问题</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">take</span></span>(v: Vec&lt;<span class="keyword">i32</span>&gt;) {
    <span class="comment">// what happens here isn’t important.</span>
}

<span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

take(v);

<span class="built_in">println!</span>(<span class="string">"v[0] is: {}"</span>, v[<span class="number">0</span>]);
</code></pre><p>这时候也会报错。</p>
<p>之所以发生这种情况，是因为变量内容是指针，赋值以后牵涉到了指针复制，多于一个指针指向同一个数据就会被rust报警。</p>
<p>如果赋值的时候只发生值赋值就不会有这种问题了。</p>
<pre><code><span class="keyword">let</span> <span class="variable">v =</span> <span class="number">1</span>;

<span class="keyword">let</span> <span class="variable">v2 =</span> v;

println!(<span class="string">"v is: {}"</span>, v);
</code></pre><p>但是！一般性大多数函数的参数都是传址的，如果我想调用一个函数继续使用刚才那些变量怎么办？rust这么建议。。。</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(v1: Vec&lt;<span class="keyword">i32</span>&gt;, v2: Vec&lt;<span class="keyword">i32</span>&gt;) -&gt; (Vec&lt;<span class="keyword">i32</span>&gt;, Vec&lt;<span class="keyword">i32</span>&gt;, <span class="keyword">i32</span>) {
    <span class="comment">// do stuff with v1 and v2</span>

    <span class="comment">// hand back ownership, and the result of our function</span>
    (v1, v2, <span class="number">42</span>)
}

<span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="keyword">let</span> v2 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="keyword">let</span> (v1, v2, answer) = foo(v1, v2);
</code></pre><p>够繁琐的 wtf。还是python 大法好，就是慢了点。。。</p>
<h2 id="Borrowing">Borrowing</h2><p>喘口气，我们继续看，上一节说到函数一旦传入一个参数这个参数就不可用了。吃了一惊，还好borrowing这个概念避免了这种情况发生</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(v1: &amp;Vec&lt;<span class="keyword">i32</span>&gt;, v2: &amp;Vec&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">i32</span> {
    <span class="comment">// do stuff with v1 and v2</span>

    <span class="comment">// return the answer</span>
    <span class="number">42</span>
}

<span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="keyword">let</span> v2 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="keyword">let</span> answer = foo(&amp;v1, &amp;v2);
</code></pre><p>这里就能继续使用v1, v2了，这里使用了borrowing这个概念, &amp;T就是借用T，但不销毁T，如果不在作用域中。当然&amp;T默认也是不可改的(immutable)，需要改变T必须使用&amp;mut T。</p>
<p>规则：<br>1.borrow的作用域必须小于owner<br>2.可以有mutable或者immutable的borrow，但同时只能有一个类型<br>3.immutable类型的borrow可以同时有多个。<br>4.mutable类型的borrow同时只能有一个。</p>
<pre><code><span class="keyword">let</span> y: &amp;i32;
{ 
    <span class="keyword">let</span> <span class="variable">x =</span> <span class="number">5</span>;
    <span class="variable">y =</span> &amp;x;
}

println!(<span class="string">"{}"</span>, y);
</code></pre><p>这也是一种错误，y被赋予了x的地址，但是离开大括号以后x就被释放了，所以这时候println打印的地址被释放了，报错。<br>这种错误在另一种情况也会发生，就是指针在指针指向的变量初始化前就产生了：</p>
<pre><code><span class="keyword">let</span> y: &amp;i32;
<span class="keyword">let</span> <span class="variable">x =</span> <span class="number">5</span>;
<span class="variable">y =</span> &amp;x;

println!(<span class="string">"{}"</span>, y);
</code></pre><p>也会报错</p>
<h2 id="生命周期">生命周期</h2><p>lifetime的设计就是用来处理野指针的，考虑以下场景</p>
<p>1.我申请了一个资源，并获得了指向这个资源的指针<br>2.我把这个指针借给了别人<br>3.我不用这个资源了，释放了这个资源<br>4.别人继续用这个指针</p>
<p>这就是所谓的dangling pointer。为了确保这个事情不发生，必须保证4在3以前发生。这就引入了指针的生命周期</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">bar</span></span>&lt;'a&gt;(x: &amp;'a <span class="keyword">i32</span>){
}
</code></pre><p>这里就显式的申明了x的生命周期与bar相同。他们的生命周期都是a。</p>
<p>同c里面一样，rust也有’static，对于标明了生命周期为’static的变量，他不会被销毁，直到程序结束。</p>
<p>对于函数中返回值的lifetime，只有三种情况可以省略：</p>
<ol>
<li>所有省略了的lifetime变成了不同的lifetime</li>
<li>如果有明确指定的输入lifetime，这个lifetime会被指派给这个函数所有的省略lifetime的返回值</li>
<li>如果有多个输入的lifetime，但其中一个是&amp;self或者&amp;mut self，那么这个self的lifetime将会被指派给所有省略lifetime的返回值</li>
</ol>
<p>其他所有情况，省略一个返回值的lifetime都会报错</p>
<p>ps<br>这里要稍微吐槽一下rust，为了防止数据被多线程更改所以搞了一个所有权概念，为了有利于更改搞了一个borrow，为了保证更改完了不会被data race又搞了一个lifetime，真是越来越复杂呢。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/20/learning-rust-part-V/" data-id="cicfzby7300164zv45kpyf3ws" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-IV" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/20/learning-rust-part-IV/" class="article-date">
  <time datetime="2015-07-20T06:25:13.000Z" itemprop="datePublished">2015-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/20/learning-rust-part-IV/">rust学习笔记(四)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基本语法">基本语法</h1><h2 id="变量绑定">变量绑定</h2><p>let 用于绑定变量，rust会自动推断类型名字，也可以自己指定类型，例如：</p>
<pre><code><span class="tag">let</span> <span class="rule"><span class="attribute">x</span>:<span class="value"> i32 = <span class="number">5</span></span></span>;
</code></pre><p>但是要注意的是所有变量初始化以后都是immutable的，需要添加mut才能改变变量的值。</p>
<pre><code><span class="keyword">let</span> mut <span class="variable">x=</span><span class="number">5</span>;
<span class="variable">x=</span><span class="number">10</span>;
</code></pre><p>不初始化的变量能过编译(会warning)，不能执行(报错)。</p>
<h2 id="函数">函数</h2><p>fn用于定义函数，基本格式如下：</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="keyword">i32</span>, y: <span class="keyword">i32</span>)-&gt;<span class="keyword">i32</span>{
}
</code></pre><p>参数后的类型指定了参数的类型，函数定义后的-&gt;代表了返回类型，函数的最后一行的结果决定了他返回什么值，所以这个返回值要符合返回值类型，并且不需要分号(;)结尾。<br>rust也支持return返回值，但不这么推荐。</p>
<h2 id="原始类型">原始类型</h2><p>rust里的primitive类型有这几个，boolean, char, numeric(i8, i16, i32, i64, u8, u16, u32, u64, isize, usize, f32, f64)</p>
<h2 id="数组">数组</h2><pre><code><span class="keyword">let</span> <span class="variable">a=</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];
<span class="keyword">let</span> mut <span class="variable">m=</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];
</code></pre><p>数组的类型是[T;N], T代表通用类型，N是数组长度，编译时决定。</p>
<p>利用这个也能初始化数组，比如</p>
<p>let a=[0;20]</p>
<p>就是20个0组成的数组。</p>
<h2 id="切片">切片</h2><p>数组能切片，比如</p>
<pre><code><span class="keyword">let</span> <span class="variable">a=</span>[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
<span class="keyword">let</span> <span class="variable">middle=</span>&amp;a[<span class="number">1</span>..<span class="number">4</span>];
<span class="keyword">let</span> <span class="variable">complete=</span>&amp;a[..];
</code></pre><h2 id="字符串">字符串</h2><p>字符串类型 str</p>
<h2 id="tuple">tuple</h2><p>rust里的tuple和python的一样</p>
<pre><code><span class="keyword">let</span> <span class="variable">x=</span>(<span class="number">1</span>,<span class="string">"hello"</span>);
</code></pre><p>定义只有一个值的tuple也需要加一个,</p>
<p>取值可以用下标</p>
<pre><code><span class="keyword">let</span> <span class="variable">a=</span> x.<span class="number">0</span>;
<span class="keyword">let</span> <span class="variable">b=</span> x.<span class="number">1</span>;
</code></pre><h2 id="函数-1">函数</h2><p>函数也有类型</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> {x}

<span class="keyword">let</span> x: <span class="function"><span class="keyword">fn</span></span>(<span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> = foo;
</code></pre><p>这种情况下x就是一个函数指针指向一个需要i32参数返回一个i32值的函数</p>
<h1 id="注释">注释</h1><p>注释之前已经说过了，这里就不说了。</p>
<h1 id="if">if</h1><p>rust里的if可以当做传统方法写</p>
<pre><code><span class="keyword">let</span> <span class="variable">x =</span> <span class="number">5</span>;

<span class="keyword">if</span> <span class="variable">x =</span>= <span class="number">5</span> {
    println!(<span class="string">"x is five!"</span>);
} <span class="keyword">else</span> {
    println!(<span class="string">"x is not five :("</span>);
}
</code></pre><p>也可以用函数式的方法写，推荐这么写：</p>
<pre><code><span class="keyword">let</span> <span class="variable">x =</span> <span class="number">5</span>;

<span class="keyword">let</span> <span class="variable">y =</span> <span class="keyword">if</span> <span class="variable">x =</span>= <span class="number">5</span> { <span class="number">10</span> } <span class="keyword">else</span> { <span class="number">15</span> };
</code></pre><p>当然这种写法就必须保证if有else 分支，并且每个分支的返回类型相同。</p>
<h2 id="for循环">for循环</h2><p>rust里的for循环也和python有点像:</p>
<pre><code><span class="keyword">for</span> <span class="keyword">var</span> <span class="keyword">in</span> expression{
    code
}
</code></pre><p>这个expression应该是一个迭代器(iterator)</p>
<h2 id="while循环">while循环</h2><p>rust也有while循环</p>
<pre><code><span class="keyword">let</span> mut x = <span class="number">5</span>; <span class="comment">// mut x: i32</span>
<span class="keyword">let</span> mut <span class="keyword">done</span> = <span class="keyword">false</span>; <span class="comment">// mut done: bool</span>

<span class="keyword">while</span> !<span class="keyword">done</span> {
    x += x - <span class="number">3</span>;

    println!(<span class="string">"{}"</span>, x);

    <span class="keyword">if</span> x % <span class="number">5</span> == <span class="number">0</span> {
        <span class="keyword">done</span> = <span class="keyword">true</span>;
    }
}
</code></pre><p>在循环里也可以用continue和break，用法同python</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/20/learning-rust-part-IV/" data-id="cicfzby76001a4zv4dtwlxubu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-III" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/17/learning-rust-part-III/" class="article-date">
  <time datetime="2015-07-17T07:38:28.000Z" itemprop="datePublished">2015-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/17/learning-rust-part-III/">rust学习笔记(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="迭代器(Iterator)">迭代器(Iterator)</h2><p>rust带了迭代器，而其似乎特别推崇使用迭代器(这点倒是和python很像)，例如：</p>
<pre><code><span class="keyword">let</span> nums = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..nums.len() {
    <span class="built_in">println!</span>(<span class="string">"{}"</span>, nums[i]);
}
</code></pre><p>这种写法远比</p>
<pre><code><span class="keyword">let</span> nums = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="keyword">for</span> num <span class="keyword">in</span> &amp;nums {
    <span class="built_in">println!</span>(<span class="string">"{}"</span>, num);
}
</code></pre><p>要差，原因有二，1,第二种更直观，2,第二种不需要做数组的边界检查。与之相关的概念还有两个，迭代器适配器以及消费者，先讲消费者</p>
<h2 id="消费者(Consumer)">消费者(Consumer)</h2><p>消费者很简单，就是一个collect()，collect消费迭代器产生的数据返回一个集合，例如</p>
<pre><code><span class="keyword">let</span> <span class="variable">one_to_one_hundred =</span> (<span class="number">1</span>..<span class="number">101</span>).collect();
</code></pre><p>但这个代码是有问题的，因为collect不知道返回什么样的集合，例如，在以下例子中</p>
<pre><code><span class="keyword">let</span> x = <span class="string">"hello"</span>.chars<span class="literal">()</span>.rev<span class="literal">()</span>.collect<span class="literal">()</span>;
</code></pre><p>编译器不知道是应该返回char组成的数组Vec<char>还是一个字符串String，为了避免这种情况的发生，就必须用指定一下类型。</char></p>
<pre><code>let x = <span class="string">"hello"</span>.chars().rev().<span class="symbol">collect:</span><span class="symbol">:&lt;Vec&lt;char&gt;&gt;</span>();
let one_to_one_hundred = (<span class="number">1</span>..<span class="number">101</span>).<span class="symbol">collect:</span><span class="symbol">:&lt;Vec&lt;u32&gt;&gt;</span>();
</code></pre><p>也可以这么写</p>
<pre><code>let <span class="symbol">x:</span> <span class="constant">Vec&lt;</span>char&gt; = <span class="string">"hello"</span>.chars().rev().<span class="symbol">collect:</span><span class="symbol">:&lt;Vec&lt;char&gt;&gt;</span>();
let one_to_one_hundred = (<span class="number">1</span>..<span class="number">101</span>).<span class="symbol">collect:</span><span class="symbol">:&lt;Vec&lt;_&gt;&gt;</span>();
</code></pre><p>find也是一种消费者，拿一个匿名函数，返回一个Option，Option里面可能有东西Some(_)，也可能什么都没有(None)，这里看着好像haskell里的Maybe，果然好东西大家都会拿来用。</p>
<pre><code><span class="keyword">let</span> greater_than_forty_two = (<span class="number">0.</span>.<span class="number">100</span>)
                             .find(|x| *x &gt; <span class="number">42</span>);

<span class="keyword">match</span> greater_than_forty_two {
    <span class="type">Some</span>(_) =&gt; println!(<span class="string">"We got some numbers!"</span>),
    <span class="type">None</span> =&gt; println!(<span class="string">"No numbers found :("</span>),
}
</code></pre><p>fold也是一种消费者，需要两个参数，第一个是累加器(accumulator)，第二个是闭包</p>
<pre><code><span class="keyword">let</span> <span class="keyword">sum</span> <span class="subst">=</span> (<span class="number">1.</span><span class="built_in">.</span><span class="number">4</span>)<span class="built_in">.</span>fold(<span class="number">0</span>, <span class="subst">|</span><span class="keyword">sum</span>, x<span class="subst">|</span> <span class="keyword">sum</span> <span class="subst">+</span> x);
</code></pre><p>累加器的初始值是0,闭包的参数是sum和x，闭包内容就是sum+x，sum的初始值是0,x从迭代器里获取值。</p>
<h2 id="迭代器适配器">迭代器适配器</h2><p>最简单的迭代器适配器就是map了，从一个迭代器出发，通过对每个迭代器施加一个函数(闭包)获取另一个迭代器。但是要注意，大多数迭代器适配器都是懒惰的，他们不会主动求值</p>
<pre><code>(<span class="number">1</span>..<span class="number">100</span>).map(|x| x + <span class="number">1</span>);

 <span class="number">18</span>:<span class="number">29</span> warning: unused <span class="literal">result</span> which must be used: <span class="keyword">iterator</span> adaptors are lazy <span class="keyword">and</span> <span class="keyword">do</span> nothing unless consumed, <span class="comment">#[warn(unused_must_use)] on by default</span>
    (<span class="number">1</span>..<span class="number">100</span>).map(|x| x + <span class="number">1</span>);
</code></pre><p>take也是一种适配器</p>
<pre><code>(<span class="number">1</span>..).<span class="function"><span class="title">take</span><span class="params">(<span class="number">5</span>)</span></span>
</code></pre><p>filter也是一种适配器</p>
<pre><code>(<span class="number">1</span>..<span class="number">100</span>).<span class="function"><span class="title">filter</span><span class="params">(|&amp;x| x % <span class="number">2</span> == <span class="number">0</span>)</span></span>
</code></pre><p>值得注意的是，所有的适配器都不会主动求值，包括有副作用的函数，比如</p>
<pre><code>(<span class="number">1.</span>.<span class="number">100</span>).<span class="keyword">map</span>(|x| <span class="built_in">println</span>!(<span class="string">"{}"</span>, x));
</code></pre><p>如果想要他们主动求值，必须套在for里面</p>
<pre><code>for i in (<span class="number">1</span>..<span class="number">100</span>).map(|x| println!(<span class="string">"{}"</span>, x)).take(<span class="number">5</span>){
    println!(<span class="string">"a"</span>)<span class="comment">;</span>
}
<span class="number">1</span>
<span class="literal">a</span>
<span class="number">2</span>
<span class="literal">a</span>
<span class="number">3</span>
<span class="literal">a</span>
<span class="number">4</span>
<span class="literal">a</span>
<span class="number">5</span>
<span class="literal">a</span>
</code></pre><p>这点和haskell很不一样(也有可能我记错了)</p>
<h2 id="并发(Concurrency)">并发(Concurrency)</h2><p>并发这一块暂时没看懂回头再来补</p>
<h2 id="错误处理">错误处理</h2><p>rust有两种错误，一种叫做failure，一种叫做panic。前者可以通过代码处理继续运行，而后者则直接停止程序运行。例如</p>
<pre><code><span class="preprocessor">#[derive(Debug)]</span>
<span class="keyword">enum</span> <span class="title">Version</span>{Version1, Version2}

<span class="preprocessor">#[derive(Debug)]</span>
<span class="keyword">enum</span> <span class="title">ParseError</span>{InvalidHeaderLength, InvalidVersion}

<span class="function"><span class="keyword">fn</span> <span class="title">parse_version</span></span>(header: &amp;[<span class="keyword">u8</span>])-&gt;Result&lt;Version, ParseError&gt;{
    <span class="keyword">if</span> header.len()&lt;<span class="number">1</span>{
        <span class="keyword">return</span> Err(ParseError::InvalidHeaderLength);
    }
    <span class="keyword">match</span> header[<span class="number">0</span>]{
        <span class="number">1</span>=&gt;Ok(Version::Version1),
        <span class="number">2</span>=&gt;Ok(Version::Version2),
        _=&gt;Err(ParseError::InvalidVersion)
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(){

    <span class="keyword">let</span> version=parse_version(&amp;[<span class="number">3</span>]);
    <span class="keyword">match</span> version{
        Ok(v)=&gt;{
            <span class="built_in">println!</span>(<span class="string">"working with version: {:?}"</span>,v);
        }
        Err(e)=&gt;{
            <span class="built_in">println!</span>(<span class="string">"error parsing header: {:?}"</span>,e);
        }
    }
    <span class="keyword">let</span> version=parse_version(&amp;[<span class="number">1</span>]);
    <span class="keyword">for</span> i <span class="keyword">in</span> version
    <span class="keyword">match</span> version{
        Ok(v)=&gt;{
            <span class="built_in">println!</span>(<span class="string">"working with version: {:?}"</span>,v);
        }
        Err(e)=&gt;{
            <span class="built_in">println!</span>(<span class="string">"error parsing header: {:?}"</span>,e);
        }
    }
}
</code></pre><p>这里就是普通的failure，对于panic，我们之前已经用到的unwrap产生的就是panic，事实上unwrap的工作就是将failure处理(upgrade)为panic。例如</p>
<pre><code><span class="rule"><span class="attribute">io</span>:<span class="value">:<span class="function">stdin</span>().<span class="function">read_line</span>(&amp;mut buffer).<span class="function">unwrap</span>()</span></span>;
</code></pre><p>unwrap的意思就是如果碰到OK就通过，但碰到Err就报错退出。</p>
<p>let mut buffer = String::new();<br>let input = io::stdin().read_line(&amp;mut buffer)<br>                       .ok()<br>                       .expect(“Failed to read line”);</p>
<p>这里用ok更优美点，ok将Result转化为Option，如果发生None，那打印expect的参数退出。expect做的事情很unwrap差不多。</p>
<p>对于函数的错误还有try!这个宏，但是try!这个宏只能在返回Result类型的函数内使用，try失败就返回一个Result类型了，所以main中不能使用try，因为main的返回值不是Result。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/17/learning-rust-part-III/" data-id="cicfzby78001c4zv4cvd1huc1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-II" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/17/learning-rust-part-II/" class="article-date">
  <time datetime="2015-07-17T03:04:24.000Z" itemprop="datePublished">2015-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/17/learning-rust-part-II/">rust学习笔记(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="多线程">多线程</h2><p>继续学习rust，今天看的是一个怎么利用rust写多线程的例子。这个问题叫做哲学家吃饭，一张圆桌子五个哲学家，每人吃饭都要先拿起左手的筷子再拿右手的筷子，吃完放回去。但如果统一拿左手的筷子，必然会发生线程死锁:每个人都拿了左手的筷子并且等右手的筷子。</p>
<pre><code><span class="keyword">use</span> std::thread;<span class="comment">//引入线程</span>
<span class="keyword">use</span> std::sync::{Mutex, Arc};<span class="comment">//引入锁和原子操作</span>

<span class="keyword">struct</span> Table{
    forks: Vec&lt;Mutex&lt;()&gt;&gt;,<span class="comment">//这是个锁组成的数组，数组的每个元素代表一双筷子</span>
}

<span class="keyword">struct</span> Philosopher{
    name: String,
    left: usize,<span class="comment">//哲学家的左右手代表了锁在数组中的相应位置</span>
    right: usize,
}

<span class="keyword">impl</span> Philosopher{
    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="keyword">str</span>, left: usize, right: usize)-&gt;Philosopher{
        Philosopher{
            name :name.to_string(),
            left: left,
            right: right,
        }
    }
    <span class="function"><span class="keyword">fn</span> <span class="title">eat</span></span>(&amp;<span class="keyword">self</span>, table: &amp;Table){
        <span class="keyword">let</span> _left = table.forks[<span class="keyword">self</span>.left].lock().unwrap();<span class="comment">//获取锁，_left前的_代表不对起不使用进行报警</span>
        <span class="keyword">let</span> _right=table.forks[<span class="keyword">self</span>.right].lock().unwrap();<span class="comment">//unwrap代表当获取锁失败时无视失败，并且将failure变成panic!</span>
        <span class="built_in">println!</span>(<span class="string">"{} is eating."</span>,<span class="keyword">self</span>.name);
        thread::sleep_ms(<span class="number">1000</span>);
        <span class="built_in">println!</span>(<span class="string">"{} is done eating."</span>, <span class="keyword">self</span>.name);
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> table = Arc::new(Table {forks: <span class="built_in">vec!</span>[
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            ]});<span class="comment">//(Table {...})是建立了一个Table对象，由于我们没有给Table绑一个new函数所以需要这种方法新建对象。</span>
            <span class="comment">//Arc(Atomic reference count)代表这个Table是支持原子引用计数的，每在一个线程中分享，就加一，这个线程退出就减一。</span>

    <span class="keyword">let</span> philosophers=<span class="built_in">vec!</span>[
        Philosopher::new(<span class="string">"Baruch Spinoza"</span>,<span class="number">0</span>,<span class="number">1</span>),
        Philosopher::new(<span class="string">"Gilles Deleuze"</span>,<span class="number">1</span>,<span class="number">2</span>),
        Philosopher::new(<span class="string">"Karl Marx"</span>,<span class="number">2</span>,<span class="number">3</span>),
        Philosopher::new(<span class="string">"Friedrich Nietzsche"</span>,<span class="number">3</span>,<span class="number">4</span>),
        Philosopher::new(<span class="string">"Michel Foucault"</span>,<span class="number">0</span>,<span class="number">4</span>),<span class="comment">//防止死锁的小技巧，先获取0再获取4</span>
    ];
    <span class="keyword">let</span> handles: Vec&lt;_&gt;=philosophers.into_iter().map(|p|{<span class="comment">//into_iter将数组转换为迭代器(iterator)</span>
            <span class="keyword">let</span> table = table.clone();<span class="comment">//这里将原始引用复制一份</span>
            thread::spawn(move||{<span class="comment">//起一个线程执行对应的p.eat, move用于维持闭包，获得eat的返回值</span>
                p.eat(&amp;table);
                })}).collect();
    <span class="keyword">for</span> h <span class="keyword">in</span> handles{
        h.join().unwrap();<span class="comment">//等每个线程结束</span>
    }
}
</code></pre><h2 id="FFI">FFI</h2><p>rust还很好的支持了FFI(foreign function interface)，能够在别的语言中调用rust写的库，例如<br>新建一个项目</p>
<pre><code><span class="variable">$ </span>cargo new embed
<span class="variable">$ </span>cd embed
</code></pre><p>里面填这些代码</p>
<pre><code><span class="keyword">use</span> std::thread;

<span class="preprocessor">#[no_mangle]</span><span class="comment">//产生外部能辨认的symbol</span>
<span class="keyword">pub</span> <span class="keyword">extern</span> <span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(){<span class="comment">//pub 和extern代表将process函数公开，外部可调用</span>
    <span class="keyword">let</span> handles: Vec&lt;_&gt;=(<span class="number">0</span>..<span class="number">10</span>).map(|_|{
        thread::spawn(||{
            <span class="keyword">let</span> <span class="keyword">mut</span> _x=<span class="number">0</span>;
            <span class="keyword">for</span> _ <span class="keyword">in</span> (<span class="number">0</span>..<span class="number">5_000_001</span>){
                _x+=<span class="number">1</span>
            }
        })
    }).collect();
    <span class="keyword">for</span> h <span class="keyword">in</span> handles{
        h.join().ok().expect(<span class="string">"Could not join a thread!"</span>);
    }
}
</code></pre><p>更改配置文件</p>
<pre><code>vi Cargo.toml
[lib]
name = <span class="string">"embed"</span>
<span class="keyword">crate</span>-<span class="keyword">type</span> = [<span class="string">"dylib"</span>]<span class="comment">//标准动态链接库，不然默认是rlib</span>
</code></pre><p>编译</p>
<pre><code>$ cargo build <span class="comment">--release</span>
</code></pre><p>python中调用</p>
<pre><code>from ctypes import cdll
lib = cdll.<span class="function"><span class="title">LoadLibrary</span><span class="params">(<span class="string">"target/release/libembed.so"</span>)</span></span>
lib.<span class="function"><span class="title">process</span><span class="params">()</span></span>
<span class="function"><span class="title">print</span><span class="params">(<span class="string">"done!"</span>)</span></span>
</code></pre><h2 id="测试">测试</h2><p>大致看了一下rust里的测试部分，感觉做的还很贴心方便，和python里的unittest不一样的是，rust直接将测试整合了进来，一共三种测试：和每个function一起的单元测试，整合（integration）测试，文档测试。</p>
<pre><code><span class="variable">$ </span>cargo new adder
<span class="variable">$ </span>cd adder
</code></pre><p>打开src/lib.rs</p>
<pre><code><span class="comment">//! The `adder` crate provides functions that add numbers to other numbers.</span>
<span class="comment">//!</span>
<span class="comment">//! # Examples</span>
<span class="comment">//!</span>
<span class="comment">//! <figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//<span class="exclamation_mark">!</span> <span class="function_or_atom">assert_eq</span><span class="exclamation_mark">!</span>(<span class="number">4</span>, <span class="function_or_atom">adder</span>::<span class="function_or_atom">add_two</span>(<span class="number">2</span>));</span><br><span class="line">//<span class="exclamation_mark">!</span></span><br></pre></td></tr></table></figure></span>


<span class="comment">/// This function adds two to its argument.</span>
<span class="comment">///</span>
<span class="comment">/// # Examples</span>
<span class="comment">///</span>
<span class="comment">/// <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// use adder::add_two;</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(4, add_two(2));</span></span><br><span class="line"><span class="comment">///</span></span><br></pre></td></tr></table></figure></span>

<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_two</span></span>(a:<span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span>{
    a+<span class="number">2</span>
}

<span class="preprocessor">#[cfg(test)]</span>
<span class="keyword">mod</span> tests {
    <span class="keyword">use</span> super::*;

    <span class="preprocessor">#[test]</span>
    <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() {  
        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, add_two(<span class="number">2</span>));
    }
}
</code></pre><p>斜杠开头的那几行是文档测试，测试内容用<code>xxxx</code>包围起来，支持markdown。///开头的是函数级别的测试，//!是模块级别的测试。#[cfg(test)]那里是单元测试。可以很方便的写一些辅助函数帮助测试，在非cargo test的时候这一部分代码不会编译。还有一种就是另建一个tests目录，tests/lib.rs，做整合测试。</p>
<pre><code><span class="keyword">extern</span> <span class="keyword">crate</span> adder;

<span class="preprocessor">#[test]</span>
<span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>(){
    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::add_two(<span class="number">2</span>));
}
</code></pre><h2 id="条件编译">条件编译</h2><p>rust也支持条件编译，例如</p>
<pre><code>#[<span class="function"><span class="title">cfg</span><span class="params">(foo)</span></span>]

#[<span class="function"><span class="title">cfg</span><span class="params">(bar = <span class="string">"baz"</span>)</span></span>]

#[<span class="function"><span class="title">cfg</span><span class="params">(any(unix, windows)</span></span>)]

#[<span class="function"><span class="title">cfg</span><span class="params">(all(unix, target_pointer_width = <span class="string">"32"</span>)</span></span>)]

#[<span class="function"><span class="title">cfg</span><span class="params">(not(foo)</span></span>)]
</code></pre><p>在函数定义的上一行写下这些字段，能帮助cargo决定这个函数是不是要在当前条件下编译。<br>在Cargo.toml中</p>
<pre><code>[features]
<span class="preprocessor"># no features by default</span>
<span class="default"><span class="keyword">default</span> = []</span>
</code></pre><h2 id="文档">文档</h2><p>刚才已经提到过，需要用///来注释文档，但需要注意的是，文档需要写成这样</p>
<pre><code><span class="dartdoc"><span class="markdown">/// The <span class="code">`Option`</span> type. See [<span class="link_label">the module level documentation</span>](<span class="link_url">../</span>) for more.</span></span>
<span class="keyword">enum</span> Option&lt;T&gt; {
    <span class="dartdoc"><span class="markdown">/// No value</span></span>
    None,
    <span class="dartdoc"><span class="markdown">/// Some value <span class="code">`T`</span></span></span>
    Some(T),
}
</code></pre><p>而不是这样</p>
<pre><code><span class="dartdoc"><span class="markdown">/// The <span class="code">`Option`</span> type. See [<span class="link_label">the module level documentation</span>](<span class="link_url">../</span>) for more.</span></span>
<span class="keyword">enum</span> Option&lt;T&gt; {
    None, <span class="dartdoc"><span class="markdown">/// No value</span></span>
    Some(T), <span class="dartdoc"><span class="markdown">/// Some value <span class="code">`T`</span></span></span>
}
</code></pre><p>使用</p>
<pre><code><span class="title">cargo</span> doc
</code></pre><p>生成文档</p>
<p>大致了解了一下，接下去继续看详细的语法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/17/learning-rust-part-II/" data-id="cicfzby7a001e4zv4xflbskzc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/RDD/">RDD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/benchmark/">benchmark</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/">blog</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cnblogs/">cnblogs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cython/">cython</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dataframe/">dataframe</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/f2py/">f2py</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/migrate/">migrate</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mllib/">mllib</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/numba/">numba</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/numpy/">numpy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pyspark/">pyspark</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rdd/">rdd</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rust/">rust</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala/">scala</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scheduler/">scheduler</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/task/">task</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/RDD/" style="font-size: 10px;">RDD</a><a href="/tags/benchmark/" style="font-size: 10px;">benchmark</a><a href="/tags/blog/" style="font-size: 12px;">blog</a><a href="/tags/cnblogs/" style="font-size: 10px;">cnblogs</a><a href="/tags/cython/" style="font-size: 10px;">cython</a><a href="/tags/dataframe/" style="font-size: 10px;">dataframe</a><a href="/tags/f2py/" style="font-size: 10px;">f2py</a><a href="/tags/github/" style="font-size: 10px;">github</a><a href="/tags/hexo/" style="font-size: 12px;">hexo</a><a href="/tags/migrate/" style="font-size: 10px;">migrate</a><a href="/tags/mllib/" style="font-size: 12px;">mllib</a><a href="/tags/numba/" style="font-size: 10px;">numba</a><a href="/tags/numpy/" style="font-size: 10px;">numpy</a><a href="/tags/pyspark/" style="font-size: 10px;">pyspark</a><a href="/tags/python/" style="font-size: 16px;">python</a><a href="/tags/rdd/" style="font-size: 10px;">rdd</a><a href="/tags/rust/" style="font-size: 20px;">rust</a><a href="/tags/scala/" style="font-size: 14px;">scala</a><a href="/tags/scheduler/" style="font-size: 10px;">scheduler</a><a href="/tags/spark/" style="font-size: 18px;">spark</a><a href="/tags/task/" style="font-size: 10px;">task</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">June 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/04/">April 2012</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">March 2012</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/01/">January 2012</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/07/23/learning-rust-part-XI/">rust学习笔记(十一)</a>
          </li>
        
          <li>
            <a href="/2015/07/23/learning-rust-part-X/">rust学习笔记(十)</a>
          </li>
        
          <li>
            <a href="/2015/07/23/learning-rust-part-IX/">rust学习笔记(九)</a>
          </li>
        
          <li>
            <a href="/2015/07/21/learning-rust-part-VIII/">rust学习笔记(八)</a>
          </li>
        
          <li>
            <a href="/2015/07/21/learning-rust-part-VII/">rust学习笔记(七)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Yuankun Shi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/index.html" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>