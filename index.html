<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>彼格海德的笔记空间</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="python">
<meta property="og:type" content="website">
<meta property="og:title" content="彼格海德的笔记空间">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="彼格海德的笔记空间">
<meta property="og:description" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="彼格海德的笔记空间">
<meta name="twitter:description" content="python">
  
    <link rel="alternative" href="/atom.xml" title="彼格海德的笔记空间" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-62861406-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
<!-- Baidu Statistics -->
<script type="text/javascript">
    var _hmt = _hmt || [];
(function() {
 var hm = document.createElement("script");
 hm.src = "//hm.baidu.com/hm.js?77faa6f8da10ec42fb1c01f2947de873";
 var s = document.getElementsByTagName("script")[0]; 
 s.parentNode.insertBefore(hm, s);
 })();
</script>
<!-- End Baidu Statistics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">彼格海德的笔记空间</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">a notebook for python</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/index.html">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-learning-rust-part-IX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/23/learning-rust-part-IX/" class="article-date">
  <time datetime="2015-07-23T06:21:13.000Z" itemprop="datePublished">2015-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/23/learning-rust-part-IX/">rust学习笔记(九)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>感觉好累，休息了一天，连椭圆机都没练，感觉今天终于缓过来了，继续学习。</p>
<h2 id="Trait_对象">Trait 对象</h2><p>当代码处理多态(polymorphism)的时候，需要有一个机制来决定到底执行哪个版本的代码。这通常叫做调度(dispatch)。调度的方式一般有两种，静态和动态。rust倾向于静态调度，但也支持动态调度。</p>
<p>例如，我们定义一个trait，并对u8和string实现一个方法</p>
<pre><code>trait <span class="type">Foo</span> {
    fn <span class="keyword">method</span>(&amp;self) -&gt; <span class="type">String</span>;
}

impl <span class="type">Foo</span> <span class="keyword">for</span> u8 {
    fn <span class="keyword">method</span>(&amp;self) -&gt; <span class="type">String</span> { format!(<span class="string">"u8: {}"</span>, *self) }
}

impl <span class="type">Foo</span> <span class="keyword">for</span> <span class="type">String</span> {
    fn <span class="keyword">method</span>(&amp;self) -&gt; <span class="type">String</span> { format!(<span class="string">"string: {}"</span>, *self) }
}
</code></pre><p>这时候静态的调度就可以通过trait bounds实现</p>
<pre><code>fn do_something&lt;T: <span class="type">Foo</span>&gt;(x: T) {
    x.<span class="keyword">method</span>();
}

fn main() {
    <span class="keyword">let</span> x = <span class="number">5u8</span>;
    <span class="keyword">let</span> y = <span class="string">"Hello"</span>.to_string();

    do_something(x);
    do_something(y);
}
</code></pre><p>rust是通过单态(monomorphization)来实现静态调度的。也就是说，编译之后为每一个T类型产生一个do_something_T这样的函数，并且替换掉每一个do_something的调用为相应类型的调用。<br>这样做的好处是可以将函数内联(inline)，这样可以让程序跑得更快，但也有坏处，会产生过多的函数。另外没有充分优化过得的编译器也会让某些inline函数跑得更慢。</p>
<h2 id="dynamic_dispatch">dynamic dispatch</h2><p>rust通过特点对象(trait objects)来实现动态调度(dynamic dispatch)。trait objects的使用很简单，就是&amp;Foo 或者 Box<foo>。在调用时使用(&amp;x as &amp;Foo)转换，或者(&amp;x作为函数参数)强制转换就可以使用trait objects来实现动态调度了。例如：<br>普通转换</foo></p>
<pre><code>fn do_something(x: &amp;<span class="type">Foo</span>) {
    x.<span class="keyword">method</span>();
}

fn main() {
    <span class="keyword">let</span> x = <span class="number">5u8</span>;
    do_something(&amp;x <span class="keyword">as</span> &amp;<span class="type">Foo</span>);
}
</code></pre><p>强制转换</p>
<pre><code>fn do_something(x: &amp;<span class="type">Foo</span>) {
    x.<span class="keyword">method</span>();
}

fn main() {
    <span class="keyword">let</span> x = <span class="string">"Hello"</span>.to_string();
    do_something(&amp;x);
}
</code></pre><p>这种转换会使编译器失去原始类型的信息，所以也可以认为是”type erasure”</p>
<h2 id="closures">closures</h2><p>rust支持闭包(closures)，也就是有函数环境的匿名函数。rust闭包这样子实现</p>
<p>let plus_one = |x: i32| x + 1;</p>
<p>这样子就创建了一个闭包，闭包的参数在管道符中间，然后跟着表达式就是闭包的函数体。由于{}可以视为一个表达式，所以也可以用大括号将多行代码扩起来组成一个复杂点的闭包，这点比python好太多。</p>
<p>let plus_two = |x| {<br>    let mut result: i32 = x;</p>
<pre><code><span class="literal">result</span> += <span class="number">1</span>;
<span class="literal">result</span> += <span class="number">1</span>;

<span class="literal">result</span>
</code></pre><p>};</p>
<p>闭包也可以用类型指定返回值，</p>
<pre><code><span class="keyword">let</span> plus_one = |x: <span class="keyword">i32</span>| -&gt; <span class="keyword">i32</span> { x + <span class="number">1</span> };
</code></pre><p>但一般为了简洁不这么做</p>
<p>在python中，闭包的内部环境处理的并不好，如果引用了外部变量，那匿名函数的内部引用会随这外部变量的改变而改变，这点很坑。<br>rust部分解决了这个问题。</p>
<pre><code><span class="keyword">let</span> mut <span class="variable">num =</span> <span class="number">5</span>;
<span class="keyword">let</span> <span class="variable">plus_num =</span> |x: i32| x + num;

<span class="keyword">let</span> <span class="variable">y =</span> &amp;mut num;
</code></pre><p>这样是错误的，编译器会告诉你在定义plus_num的时候num被immutable引用了，所以y=&amp;mut num就报错了。<br>要这么做只能让闭包在他自己的作用域中，执行完以后消失</p>
<pre><code><span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;
{
    <span class="keyword">let</span> plus_num = |x: <span class="keyword">i32</span>| x + num;

} <span class="comment">// plus_num 离开作用域就消失了。</span>

<span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> num;
</code></pre><h2 id="move闭包">move闭包</h2><pre><code><span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;

{ 
    <span class="keyword">let</span> <span class="keyword">mut</span> add_num = |x: <span class="keyword">i32</span>| num += x;

    add_num(<span class="number">5</span>);
}

<span class="built_in">assert_eq!</span>(<span class="number">10</span>, num);<span class="comment">//结果是10</span>


<span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;

{ 
    <span class="keyword">let</span> <span class="keyword">mut</span> add_num = move |x: <span class="keyword">i32</span>| num += x;

    add_num(<span class="number">5</span>);
}

<span class="built_in">assert_eq!</span>(<span class="number">5</span>, num);<span class="comment">//结果是5</span>
</code></pre><p>所以在定义闭包时使用move就是对所使用的外部变量做了一个copy，即使改变了，离开了作用域还是原来的值。</p>
<h2 id="closure_实现方法">closure 实现方法</h2><p>同其他语言不一样，rust里闭包的实现其是靠的就是trait objects。</p>
<pre><code>pub <span class="keyword">trait</span> Fn<span class="subst">&lt;</span>Args<span class="subst">&gt;</span> : FnMut<span class="subst">&lt;</span>Args<span class="subst">&gt;</span> {
    extern <span class="string">"rust-call"</span> fn call(<span class="subst">&amp;</span><span class="built_in">self</span>, args: Args) <span class="subst">-&gt; </span><span class="built_in">Self</span><span class="tag">::Output</span>;
}

pub <span class="keyword">trait</span> FnMut<span class="subst">&lt;</span>Args<span class="subst">&gt;</span> : FnOnce<span class="subst">&lt;</span>Args<span class="subst">&gt;</span> {
    extern <span class="string">"rust-call"</span> fn call_mut(<span class="subst">&amp;</span>mut <span class="built_in">self</span>, args: Args) <span class="subst">-&gt; </span><span class="built_in">Self</span><span class="tag">::Output</span>;
}

pub <span class="keyword">trait</span> FnOnce<span class="subst">&lt;</span>Args<span class="subst">&gt;</span> {
    <span class="keyword">type</span> Output;

    extern <span class="string">"rust-call"</span> fn call_once(<span class="built_in">self</span>, args: Args) <span class="subst">-&gt; </span><span class="built_in">Self</span><span class="tag">::Output</span>;
}
</code></pre><p>在rust内部，所有的闭包都是以上这三个trait objects的重载</p>
<h2 id="将闭包作为参数">将闭包作为参数</h2><p>看懂了闭包的实现本质是trait objects，我们就可以看看怎么把闭包作为参数传递进别的函数中。</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">call_with_one</span></span>&lt;F&gt;(some_closure: F) -&gt; <span class="keyword">i32</span>
    where F : Fn(<span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> {

    some_closure(<span class="number">1</span>)
}

<span class="keyword">let</span> answer = call_with_one(|x| x + <span class="number">2</span>);

<span class="built_in">assert_eq!</span>(<span class="number">3</span>, answer);
</code></pre><p>这里是一个例子，在call_with_one的调用时定义了一个匿名函数，然后在定义call_with_one里，将参数定义为类型F，返回值为i32，然后接着一行where F: Fn(i32)-&gt;i32)的意思就是F这个类型其实是Fn(i32)-&gt;i32，Fn就是上一节第一个闭包。</p>
<h2 id="返回闭包">返回闭包</h2><p>能传入闭包，那能返回闭包吗？</p>
<p>能！但不能像传入闭包一样那样定义一个传出的函数，然后类型是Fn。1.是生命周期的缘故，所有内部定义的函数他的生命都不会长过函数本身，这个可以用’static定义返回值类型来避开。2.这个就比较麻烦，应为在rust编译器里，闭包直接有一个类型叫闭包，并不是Fn….3.由于在函数中定义闭包很容易以来函数内部的变量，这些变量的寿命都很短，所以rust为了避免问题就将所有的闭包定义为一个新的闭包并且没有static生命。当然这也不难解决</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">factory</span></span>() -&gt; Box&lt;Fn(<span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span>&gt; {<span class="comment">//Fn就是为了定义闭包，Box为了将闭包类型转换</span>
    <span class="keyword">let</span> num = <span class="number">5</span>;

    Box::new(move |x| x + num)<span class="comment">//move 为了将num做一份复制到闭包中，避免num本身的生命周期过短的问题</span>
}
<span class="keyword">let</span> f = factory();

<span class="keyword">let</span> answer = f(<span class="number">1</span>);
<span class="built_in">assert_eq!</span>(<span class="number">6</span>, answer);
</code></pre><p>内心不住的咆哮(我要休假！去海边！)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/23/learning-rust-part-IX/" data-id="cicfw51qj0014qtv4p5zndkpf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-VIII" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/21/learning-rust-part-VIII/" class="article-date">
  <time datetime="2015-07-21T08:09:47.000Z" itemprop="datePublished">2015-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/21/learning-rust-part-VIII/">rust学习笔记(八)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Vector">Vector</h2><p>这个应该翻译成向量，因为教程自己都说了<br>A ‘vector’ is a dynamic or ‘growable’ array<br>定义和遍历向量的方法之前的笔记里已经提到过，相当简单</p>
<pre><code><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

<span class="keyword">for</span> i <span class="keyword">in</span> &amp;v {
    <span class="built_in">println!</span>(<span class="string">"A reference to {}"</span>, i);
}

<span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v {
    <span class="built_in">println!</span>(<span class="string">"A mutable reference to {}"</span>, i);
}

<span class="keyword">for</span> i <span class="keyword">in</span> v {
    <span class="built_in">println!</span>(<span class="string">"Take ownership of the vector and its element {}"</span>, i);
}
</code></pre><h2 id="字符串">字符串</h2><p>有意思的是，在rust里字符串有两种类型，一种叫做&amp;str(注意那个&amp;，说明是个指针？)一种叫做String。对于&amp;str，其实他的默认生命周期是’static的，所以会永久保存直到程序结束。并且&amp;str的长度固定，不能被改变。<br>而String的长度是可变的，保证是UTF8，String通常是通过&amp;str的to_string()方法创造的。String能通过加一个&amp;强制转换成&amp;str。</p>
<pre><code><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="string">"Hello"</span>.to_string(); 
<span class="built_in">println!</span>(<span class="string">"{}"</span>, s);

s.push_str(<span class="string">", world."</span>);
<span class="built_in">println!</span>(<span class="string">"{}"</span>, s);

<span class="function"><span class="keyword">fn</span> <span class="title">takes_slice</span></span>(slice: &amp;<span class="keyword">str</span>) {
    <span class="built_in">println!</span>(<span class="string">"Got: {}"</span>, slice);
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> s = <span class="string">"Hello"</span>.to_string();
    takes_slice(&amp;s);
}
</code></pre><h2 id="索引">索引</h2><p>通常，应为字符串是utf-8的，所以字符串不支持索引(&amp;str也不支持)</p>
<pre><code><span class="keyword">let</span> s = <span class="string">"hello"</span>;

<span class="built_in">println!</span>(<span class="string">"The first letter of s is {}"</span>, s[<span class="number">0</span>]);<span class="comment">//报错</span>
</code></pre><p>但是可以通过别的方法遍历</p>
<pre><code><span class="keyword">let</span> s = <span class="string">"关关雎鸠，在河之洲。窈窕淑女，君子好逑。"</span>;
<span class="keyword">for</span> b <span class="keyword">in</span> s.as_bytes(){
    <span class="built_in">print</span>!(<span class="string">"{}, "</span>,b);
}

<span class="built_in">println</span>!(<span class="string">""</span>);

<span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> s.chars(){
    <span class="built_in">print</span>!(<span class="string">"{}, "</span>,<span class="built_in">c</span>);
}
<span class="built_in">println</span>!(<span class="string">""</span>);
</code></pre><p>以及索引</p>
<pre><code><span class="keyword">let</span> <span class="variable">guan =</span> s.chars().nth(<span class="number">1</span>);
</code></pre><h2 id="字符连接">字符连接</h2><p>rust的字符连接稍微复杂点，String后可以加&amp;str来连接，但是如果两个String，第二个String必须用&amp;强制转换为&amp;str，如果是两个&amp;str，第一个必须用.to_string()转化为String</p>
<h2 id="通用类型">通用类型</h2><p>rust支持T作为通用类型来支持多种类型的函数，枚举等等。</p>
<pre><code><span class="keyword">fn</span> takes_anything&lt;<span class="constant">T&gt;</span>(<span class="symbol">x:</span> <span class="constant">T)</span> {
    <span class="regexp">//</span> <span class="keyword">do</span> something with x
}
</code></pre><p>也可以多个通用类型，这点和Haskell很像</p>
<pre><code>fn takes_two_things&lt;T, U&gt;(<span class="string">x:</span> T, <span class="string">y:</span> U) {
    <span class="comment">// ...</span>
}
</code></pre><h2 id="Trait">Trait</h2><p>Rust里的trait类似于scala里的trait，有点像java里的抽象类，规定了这个结构必须有的方法，然后impl去实现就行。trait的好处是可以给不同类型规定必须实现的方法，例如</p>
<pre><code><span class="keyword">struct</span> Circle {
    x: <span class="keyword">f64</span>,
    y: <span class="keyword">f64</span>,
    radius: <span class="keyword">f64</span>,
}

<span class="keyword">trait</span> <span class="title">HasArea</span> {
    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">f64</span>;
}

<span class="keyword">impl</span> HasArea <span class="keyword">for</span> Circle {
    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">f64</span> {
        std::f64::consts::PI * (<span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius)
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">print_area</span></span>&lt;T&gt;(shape: T) {
    <span class="built_in">println!</span>(<span class="string">"This shape has an area of {}"</span>, shape.area());
}
</code></pre><p>这样是会报错的，因为T这个匿名类型没有实现area这个方法。但是这样指定就没问题：</p>
<pre><code><span class="tag">fn</span> <span class="tag">print_area</span>&lt;<span class="rule"><span class="attribute">T</span>:<span class="value"> HasArea&gt;(shape: T) {
    println!(<span class="string">"This shape has an area of {}"</span>, shape.<span class="function">area</span>())</span></span>;
}
</code></pre><p>这是因为在函数名后的尖括号里规定了T必须实现HasArea这个trait规定的所有函数(也就是必须有area这个函数)，如果要指定多个trait，需要用加号</p>
<pre><code><span class="keyword">use</span> std::fmt::Debug;

<span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;T: Clone + Debug&gt;(x: T) {
    x.clone();
    <span class="built_in">println!</span>(<span class="string">"{:?}"</span>, x);
}
</code></pre><h2 id="Where">Where</h2><p>在写Trait的时候，如果变量类型一多，很容易比较乱，rust利用where，将整个trait后置，变得易于阅读。</p>
<pre><code><span class="keyword">use</span> <span class="title">std</span>::<span class="title">fmt</span>::<span class="title">Debug</span>;

fn bar&lt;T, K&gt;(x: T, y: K)
    where T: <span class="keyword">Clone</span>,
          K: <span class="keyword">Clone</span> + Debug {

    x.<span class="keyword">clone</span>();
    y.<span class="keyword">clone</span>();
    println!(<span class="string">"{:?}"</span>, y);
}
</code></pre><p>默认方法</p>
<p>在trait中，同样可以实现某个方法，这样所有指定了该trait的类型都会自动拥有这个方法。</p>
<pre><code><span class="keyword">trait</span> <span class="title">Foo</span> {
    <span class="function"><span class="keyword">fn</span> <span class="title">bar</span></span>(&amp;<span class="keyword">self</span>);

    <span class="function"><span class="keyword">fn</span> <span class="title">baz</span></span>(&amp;<span class="keyword">self</span>) { <span class="built_in">println!</span>(<span class="string">"We called baz."</span>); }
}
</code></pre><p>继承</p>
<p>trait也可以继承，也就是说实现trait a必须实现trait b。</p>
<pre><code><span class="class"><span class="keyword">trait</span> <span class="title">Foo</span> </span>{
    fn foo(&amp;self);
}

<span class="class"><span class="keyword">trait</span> <span class="title">FooBar</span> : <span class="typename">Foo {</span></span>
    fn foobar(&amp;self);
}
</code></pre><h2 id="Drop">Drop</h2><p>drop是rust里得一个特殊的trait，他的作用居然是在变量离开作用域的时候执行。通常这是用来做一些清理工作的。</p>
<pre><code><span class="keyword">struct</span> Firework {
    strength: <span class="keyword">i32</span>,
}

<span class="keyword">impl</span> Drop <span class="keyword">for</span> Firework {
    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) {
        <span class="built_in">println!</span>(<span class="string">"BOOM times {}!!!"</span>, <span class="keyword">self</span>.strength);
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> firecracker = Firework { strength: <span class="number">1</span> };
    <span class="keyword">let</span> tnt = Firework { strength: <span class="number">100</span> };
    <span class="built_in">println!</span>(<span class="string">"test"</span>);
}
</code></pre><p>这段代码的执行结果是</p>
<pre><code><span class="function_or_atom">test</span>
<span class="variable">BOOM</span> <span class="function_or_atom">times</span> <span class="number">100</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
<span class="variable">BOOM</span> <span class="function_or_atom">times</span> <span class="number">1</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
</code></pre><p>也就是说先执行了println!(“test”)，然后才执行了每个变量的drop方法。并且这是一个先进后出的栈。</p>
<h2 id="if_let">if let</h2><p>if let 主要是用来做一些模式匹配的工作，例如</p>
<pre><code>match option <span class="list">{
    Some(x) =&gt; { foo(x) }</span>,
    <span class="keyword">None</span> =&gt; <span class="list">{}</span>,
}
</code></pre><p>这么一个模式匹配，如果用if语句来做可以这么做。</p>
<pre><code><span class="keyword">if</span> <span class="built_in">option</span>.is_some<span class="literal">()</span> {
    <span class="keyword">let</span> x = <span class="built_in">option</span>.unwrap<span class="literal">()</span>;
    foo(x);
}
</code></pre><p>但是用if let可以更加简介</p>
<pre><code><span class="function"><span class="keyword">if</span> <span class="keyword">let</span> <span class="title">Some</span><span class="params">(x)</span> </span>= option {
    foo(x);
}
</code></pre><p>当模式不匹配的时候还可以用else</p>
<pre><code><span class="keyword">if</span> <span class="keyword">let</span> <span class="type">Some</span>(x) = <span class="built_in">option</span> {
    foo(x);
} <span class="keyword">else</span> {
    bar<span class="literal">()</span>;
}
</code></pre><h2 id="while_let">while let</h2><p>和if let一样，不同的是不断重复匹配</p>
<pre><code><span class="function"><span class="keyword">while</span> <span class="keyword">let</span> <span class="title">Some</span><span class="params">(x)</span> </span>= option {
    println!(<span class="string">"{}"</span>, x);
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/21/learning-rust-part-VIII/" data-id="cicfw51po000vqtv4nlluwdbc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-VII" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/21/learning-rust-part-VII/" class="article-date">
  <time datetime="2015-07-21T07:33:12.000Z" itemprop="datePublished">2015-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/21/learning-rust-part-VII/">rust学习笔记(七)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="match">match</h2><p>匹配是一个很好用的东西，在haskell中非常常见，要注意，匹配的时候必须全覆盖，加一个默认条件就能全覆盖，例如：</p>
<pre><code><span class="keyword">let</span> x = <span class="number">5</span>;

<span class="keyword">let</span> number = <span class="keyword">match</span> x {
    <span class="number">1</span> =&gt; <span class="string">"one"</span>,
    <span class="number">2</span> =&gt; <span class="string">"two"</span>,
    <span class="number">3</span> =&gt; <span class="string">"three"</span>,
    <span class="number">4</span> =&gt; <span class="string">"four"</span>,
    <span class="number">5</span> =&gt; <span class="string">"five"</span>,
    _ =&gt; <span class="string">"something else"</span>,
};
</code></pre><p>这个_就是默认条件。但匹配并不是用在这里，更多的用在枚举类型上，例如</p>
<pre><code><span class="keyword">enum</span> <span class="title">Message</span> {
    Quit,
    ChangeColor(<span class="keyword">i32</span>, <span class="keyword">i32</span>, <span class="keyword">i32</span>),
    Move { x: <span class="keyword">i32</span>, y: <span class="keyword">i32</span> },
    Write(String),
}

<span class="function"><span class="keyword">fn</span> <span class="title">quit</span></span>() { <span class="comment">/* ... */</span> }
<span class="function"><span class="keyword">fn</span> <span class="title">change_color</span></span>(r: <span class="keyword">i32</span>, g: <span class="keyword">i32</span>, b: <span class="keyword">i32</span>) { <span class="comment">/* ... */</span> }
<span class="function"><span class="keyword">fn</span> <span class="title">move_cursor</span></span>(x: <span class="keyword">i32</span>, y: <span class="keyword">i32</span>) { <span class="comment">/* ... */</span> }

<span class="function"><span class="keyword">fn</span> <span class="title">process_message</span></span>(msg: Message) {
    <span class="keyword">match</span> msg {
        Message::Quit =&gt; quit(),
        Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b),
        Message::Move { x: x, y: y } =&gt; move_cursor(x, y),
        Message::Write(s) =&gt; <span class="built_in">println!</span>(<span class="string">"{}"</span>, s),
    };
}
</code></pre><p>这里就可以根据枚举类型里不同的各种类型做各种匹配。</p>
<p>也可以做多模式匹配和区域匹配</p>
<pre><code><span class="keyword">let</span> x = <span class="number">1</span>;

<span class="keyword">match</span> x {
    <span class="number">1</span> | <span class="number">2</span> =&gt; println!(<span class="string">"one or two"</span>),
    <span class="number">3</span> ... <span class="number">5</span> =&gt; println!(<span class="string">"three"</span>),
    _ =&gt; println!(<span class="string">"anything"</span>),
}
</code></pre><p>在匹配模式比较复杂的时候还可以使用绑定</p>
<pre><code><span class="comment">#[derive(Debug)]</span>
struct <span class="type">Person</span> {
    name: <span class="type">Option</span>&lt;<span class="type">String</span>&gt;,
}

<span class="keyword">let</span> name = <span class="string">"Steve"</span>.to_string();
<span class="keyword">let</span> mut x: <span class="type">Option</span>&lt;<span class="type">Person</span>&gt; = <span class="type">Some</span>(<span class="type">Person</span> { name: <span class="type">Some</span>(name) });
match x {
    <span class="type">Some</span>(<span class="type">Person</span> { name: <span class="keyword">ref</span> a @ <span class="type">Some</span>(_), .. }) =&gt; println!(<span class="string">"{:?}"</span>, a),
    _ =&gt; {}
}
</code></pre><p>得到相应值，在多模式匹配的时候必须确保每个部分都有绑定</p>
<pre><code><span class="keyword">let</span> x = <span class="number">5</span>;

match x {
    <span class="literal">e</span> @ <span class="number">1</span> ... <span class="number">5</span> | <span class="literal">e</span> @ <span class="number">8</span> ... <span class="number">10</span> =&gt; println!(<span class="string">"got a range element {}"</span>, <span class="literal">e</span>),
    _ =&gt; println!(<span class="string">"anything"</span>),
}
</code></pre><p>还可以忽略掉具体值</p>
<pre><code><span class="keyword">enum</span> <span class="title">OptionalInt</span> {
    Value(<span class="keyword">i32</span>),
    Missing,
}

<span class="keyword">let</span> x = OptionalInt::Value(<span class="number">5</span>);

<span class="keyword">match</span> x {
    OptionalInt::Value(..) =&gt; <span class="built_in">println!</span>(<span class="string">"Got an int!"</span>),
    OptionalInt::Missing =&gt; <span class="built_in">println!</span>(<span class="string">"No such luck."</span>),
}
</code></pre><p>或者使用if来匹配</p>
<pre><code><span class="keyword">enum</span> <span class="title">OptionalInt</span> {
    Value(<span class="keyword">i32</span>),
    Missing,
}

<span class="keyword">let</span> x = OptionalInt::Value(<span class="number">5</span>);

<span class="keyword">match</span> x {
    OptionalInt::Value(i) <span class="keyword">if</span> i &gt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Got an int bigger than five!"</span>),
    OptionalInt::Value(..) =&gt; <span class="built_in">println!</span>(<span class="string">"Got an int!"</span>),
    OptionalInt::Missing =&gt; <span class="built_in">println!</span>(<span class="string">"No such luck."</span>),
}
</code></pre><p>匹配的时候与haskell一样，也可以解包具体值</p>
<pre><code><span class="keyword">struct</span> Point {
    x: <span class="keyword">i32</span>,
    y: <span class="keyword">i32</span>,
}

<span class="keyword">let</span> origin = Point { x: <span class="number">0</span>, y: <span class="number">0</span> };

<span class="keyword">match</span> origin {
    Point { x: x, .. } =&gt; <span class="built_in">println!</span>(<span class="string">"x is {}"</span>, x),
}
</code></pre><h2 id="方法">方法</h2><p>对于rust里的结构体，可以通过impl来实现这个结构体的方法，例如</p>
<pre><code><span class="keyword">struct</span> Circle {
    x: <span class="keyword">f64</span>,
    y: <span class="keyword">f64</span>,
    radius: <span class="keyword">f64</span>,
}

<span class="keyword">impl</span> Circle {
    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">f64</span> {
        std::f64::consts::PI * (<span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius)
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> c = Circle { x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, radius: <span class="number">2.0</span> };
    <span class="built_in">println!</span>(<span class="string">"{}"</span>, c.area());
}
</code></pre><p>如果要做到foo.bar().baz()这样的调用方式，bar()的返回类型必须有baz这个函数</p>
<p>在指定impl函数的时候如果不加self参数，就成为了联合函数</p>
<pre><code><span class="keyword">struct</span> Circle {
    x: <span class="keyword">f64</span>,
    y: <span class="keyword">f64</span>,
    radius: <span class="keyword">f64</span>,
}

<span class="keyword">impl</span> Circle {
    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: <span class="keyword">f64</span>, y: <span class="keyword">f64</span>, radius: <span class="keyword">f64</span>) -&gt; Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> c = Circle::new(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">2.0</span>);
}
</code></pre><p>rust没有python那样的默认参数，所以在定义类似函数时稍微麻烦点，例如</p>
<pre><code><span class="keyword">struct</span> Circle {
    x: <span class="keyword">f64</span>,
    y: <span class="keyword">f64</span>,
    radius: <span class="keyword">f64</span>,
}

<span class="keyword">impl</span> Circle {
    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">f64</span> {
        std::f64::consts::PI * (<span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius)
    }
}

<span class="keyword">struct</span> CircleBuilder {
    x: <span class="keyword">f64</span>,
    y: <span class="keyword">f64</span>,
    radius: <span class="keyword">f64</span>,
}

<span class="keyword">impl</span> CircleBuilder {
    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; CircleBuilder {
        CircleBuilder { x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, radius: <span class="number">1.0</span>, }
    }

    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, coordinate: <span class="keyword">f64</span>) -&gt; &amp;<span class="keyword">mut</span> CircleBuilder {
        <span class="keyword">self</span>.x = coordinate;
        <span class="keyword">self</span>
    }

    <span class="function"><span class="keyword">fn</span> <span class="title">y</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, coordinate: <span class="keyword">f64</span>) -&gt; &amp;<span class="keyword">mut</span> CircleBuilder {
        <span class="keyword">self</span>.y = coordinate;
        <span class="keyword">self</span>
    }

    <span class="function"><span class="keyword">fn</span> <span class="title">radius</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, radius: <span class="keyword">f64</span>) -&gt; &amp;<span class="keyword">mut</span> CircleBuilder {
        <span class="keyword">self</span>.radius = radius;
        <span class="keyword">self</span>
    }

    <span class="function"><span class="keyword">fn</span> <span class="title">finalize</span></span>(&amp;<span class="keyword">self</span>) -&gt; Circle {
        Circle { x: <span class="keyword">self</span>.x, y: <span class="keyword">self</span>.y, radius: <span class="keyword">self</span>.radius }
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> c = CircleBuilder::new()
                .x(<span class="number">1.0</span>)
                .y(<span class="number">2.0</span>)
                .radius(<span class="number">2.0</span>)
                .finalize();

    <span class="built_in">println!</span>(<span class="string">"area: {}"</span>, c.area());
    <span class="built_in">println!</span>(<span class="string">"x: {}"</span>, c.x);
    <span class="built_in">println!</span>(<span class="string">"y: {}"</span>, c.y);
}
</code></pre><p>在这个例子里，首先是定义了一个CircleBuilder，然后不断将需要改变的参数累积，最后形成一个circle类</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/21/learning-rust-part-VII/" data-id="cicfw51pq000yqtv4dt284a2f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-VI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/21/learning-rust-part-VI/" class="article-date">
  <time datetime="2015-07-21T06:56:38.000Z" itemprop="datePublished">2015-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/21/learning-rust-part-VI/">rust学习笔记(六)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="可变性(Mutability)">可变性(Mutability)</h2><p>rust的可变性已经提到过很多了，差不多就是这样子</p>
<pre><code><span class="keyword">let</span> mut <span class="variable">x =</span> <span class="number">5</span>;
<span class="keyword">let</span> <span class="variable">y =</span> &amp;mut x;
</code></pre><p>但这次要多一个概念，即内部和外部可变性。</p>
<p>我们在讨论可变性的时候，其实是在讨论外部可变性，比如</p>
<pre><code><span class="keyword">use</span> std::sync::Arc;

<span class="keyword">let</span> x = Arc::new(<span class="number">5</span>);
<span class="keyword">let</span> y = x.clone();
</code></pre><p>这样是可以的。因为符合了以下原则</p>
<ol>
<li>对一个资源的一个或者多个引用(&amp;T)</li>
<li>同时只能有一个可变引用(&amp;mut T)</li>
</ol>
<p>这就是为什么上面那段代码可行，因为任何时候T.clone()给出的都是T的不可变引用(&amp;T)</p>
<p>但下面这段就不行了</p>
<pre><code><span class="keyword">use</span> std::cell::RefCell;
<span class="keyword">let</span> x = RefCell::new(<span class="number">42</span>);
<span class="keyword">let</span> y = x.borrow_mut();
<span class="keyword">let</span> z = x.borrow_mut();
</code></pre><p>这里，y已经借出了一个&amp;mut T，所以z再借出就报错panic了。</p>
<p>由于可变性是借(&amp;mut)或者绑定(let mut)的一个属性，所以对于结构体不存在某些属性可变某些属性不可变。</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>{
    x: <span class="built_in">i32</span>,
    mut y: <span class="built_in">i32</span>,
}
</code></pre><p>这是错的，只能这么操作</p>
<pre><code><span class="keyword">struct</span> Point {
    x: <span class="keyword">i32</span>,
    y: <span class="keyword">i32</span>,
}
<span class="keyword">let</span> <span class="keyword">mut</span> a = Point { x: <span class="number">5</span>, y: <span class="number">6</span> };
a.x = <span class="number">10</span>;
<span class="keyword">let</span> b = Point { x: <span class="number">5</span>, y: <span class="number">6</span>};
b.x = <span class="number">10</span>;<span class="comment">//这里也错了，因为b的绑定是不可变的</span>
</code></pre><p>当然，可以利用Cell<t>特性模拟可变</t></p>
<pre><code><span class="keyword">use</span> std::cell::Cell;

<span class="keyword">struct</span> Point {
    x: <span class="keyword">i32</span>,
    y: Cell&lt;<span class="keyword">i32</span>&gt;,
}

<span class="keyword">let</span> point = Point { x: <span class="number">5</span>, y: Cell::new(<span class="number">6</span>) };

point.y.set(<span class="number">7</span>);

<span class="built_in">println!</span>(<span class="string">"y: {:?}"</span>, point.y);
</code></pre><h2 id="结构体">结构体</h2><p>结构体的定义和c差不多。</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>{
    x: <span class="built_in">i32</span>,
    y: <span class="built_in">i32</span>,
}
</code></pre><p>当你要更新一个结构体的时候，多了一种方法..</p>
<pre><code><span class="keyword">struct</span> Point3d {
    x: <span class="keyword">i32</span>,
    y: <span class="keyword">i32</span>,
    z: <span class="keyword">i32</span>,
}

<span class="keyword">let</span> <span class="keyword">mut</span> point = Point3d { x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> };
point = Point3d { y: <span class="number">1</span>, .. point };
</code></pre><p>这样point中除y以外的数值都会从另一个复制过来</p>
<p>Tuple structs<br>这个定义类似于tuple和struct结合体</p>
<p>struct Color(i32, i32, i32);<br>struct Point(i32, i32, i32);</p>
<p>let black = Color(0, 0, 0);<br>let origin = Point(0, 0, 0);</p>
<p>但不推荐这么写，因为没有变量名字。</p>
<p>但有的时候有奇效，比如</p>
<p>struct Inches(i32);</p>
<p>let length = Inches(10);</p>
<p>let Inches(integer_length) = length;<br>println!(“length is {} inches”, integer_length);</p>
<p>这样可以从tuple struct解包出一个数值，有点像python的unpack。</p>
<h2 id="Enums">Enums</h2><p>枚举是一个常见的东西，就不细说了<br>差不多就是把不同种类的变量类型打包成一个类型，这个类型的数据有各种变量类型的可能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/21/learning-rust-part-VI/" data-id="cicfw51ps0010qtv40zib179d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-V" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/20/learning-rust-part-V/" class="article-date">
  <time datetime="2015-07-20T07:32:11.000Z" itemprop="datePublished">2015-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/20/learning-rust-part-V/">rust学习笔记(五)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="所有权">所有权</h2><p>rust里有数据所有权这个概念</p>
<pre><code><span class="keyword">let</span> <span class="variable">v =</span> vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="keyword">let</span> <span class="variable">v2 =</span> v;

println!(<span class="string">"v[0] is: {}"</span>, v[<span class="number">0</span>]);
</code></pre><p>这里会报错，因为v本质是一个指针，指向数据的指针，v2被赋值以后也是。这样就发生数据竞争，所以v这个引用不再可用。</p>
<p>并且，在调用函数时也会发生类似问题</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">take</span></span>(v: Vec&lt;<span class="keyword">i32</span>&gt;) {
    <span class="comment">// what happens here isn’t important.</span>
}

<span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

take(v);

<span class="built_in">println!</span>(<span class="string">"v[0] is: {}"</span>, v[<span class="number">0</span>]);
</code></pre><p>这时候也会报错。</p>
<p>之所以发生这种情况，是因为变量内容是指针，赋值以后牵涉到了指针复制，多于一个指针指向同一个数据就会被rust报警。</p>
<p>如果赋值的时候只发生值赋值就不会有这种问题了。</p>
<pre><code><span class="keyword">let</span> <span class="variable">v =</span> <span class="number">1</span>;

<span class="keyword">let</span> <span class="variable">v2 =</span> v;

println!(<span class="string">"v is: {}"</span>, v);
</code></pre><p>但是！一般性大多数函数的参数都是传址的，如果我想调用一个函数继续使用刚才那些变量怎么办？rust这么建议。。。</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(v1: Vec&lt;<span class="keyword">i32</span>&gt;, v2: Vec&lt;<span class="keyword">i32</span>&gt;) -&gt; (Vec&lt;<span class="keyword">i32</span>&gt;, Vec&lt;<span class="keyword">i32</span>&gt;, <span class="keyword">i32</span>) {
    <span class="comment">// do stuff with v1 and v2</span>

    <span class="comment">// hand back ownership, and the result of our function</span>
    (v1, v2, <span class="number">42</span>)
}

<span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="keyword">let</span> v2 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="keyword">let</span> (v1, v2, answer) = foo(v1, v2);
</code></pre><p>够繁琐的 wtf。还是python 大法好，就是慢了点。。。</p>
<h2 id="Borrowing">Borrowing</h2><p>喘口气，我们继续看，上一节说到函数一旦传入一个参数这个参数就不可用了。吃了一惊，还好borrowing这个概念避免了这种情况发生</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(v1: &amp;Vec&lt;<span class="keyword">i32</span>&gt;, v2: &amp;Vec&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">i32</span> {
    <span class="comment">// do stuff with v1 and v2</span>

    <span class="comment">// return the answer</span>
    <span class="number">42</span>
}

<span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="keyword">let</span> v2 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="keyword">let</span> answer = foo(&amp;v1, &amp;v2);
</code></pre><p>这里就能继续使用v1, v2了，这里使用了borrowing这个概念, &amp;T就是借用T，但不销毁T，如果不在作用域中。当然&amp;T默认也是不可改的(immutable)，需要改变T必须使用&amp;mut T。</p>
<p>规则：<br>1.borrow的作用域必须小于owner<br>2.可以有mutable或者immutable的borrow，但同时只能有一个类型<br>3.immutable类型的borrow可以同时有多个。<br>4.mutable类型的borrow同时只能有一个。</p>
<pre><code><span class="keyword">let</span> y: &amp;i32;
{ 
    <span class="keyword">let</span> <span class="variable">x =</span> <span class="number">5</span>;
    <span class="variable">y =</span> &amp;x;
}

println!(<span class="string">"{}"</span>, y);
</code></pre><p>这也是一种错误，y被赋予了x的地址，但是离开大括号以后x就被释放了，所以这时候println打印的地址被释放了，报错。<br>这种错误在另一种情况也会发生，就是指针在指针指向的变量初始化前就产生了：</p>
<pre><code><span class="keyword">let</span> y: &amp;i32;
<span class="keyword">let</span> <span class="variable">x =</span> <span class="number">5</span>;
<span class="variable">y =</span> &amp;x;

println!(<span class="string">"{}"</span>, y);
</code></pre><p>也会报错</p>
<h2 id="生命周期">生命周期</h2><p>lifetime的设计就是用来处理野指针的，考虑以下场景</p>
<p>1.我申请了一个资源，并获得了指向这个资源的指针<br>2.我把这个指针借给了别人<br>3.我不用这个资源了，释放了这个资源<br>4.别人继续用这个指针</p>
<p>这就是所谓的dangling pointer。为了确保这个事情不发生，必须保证4在3以前发生。这就引入了指针的生命周期</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">bar</span></span>&lt;'a&gt;(x: &amp;'a <span class="keyword">i32</span>){
}
</code></pre><p>这里就显式的申明了x的生命周期与bar相同。他们的生命周期都是a。</p>
<p>同c里面一样，rust也有’static，对于标明了生命周期为’static的变量，他不会被销毁，直到程序结束。</p>
<p>对于函数中返回值的lifetime，只有三种情况可以省略：</p>
<ol>
<li>所有省略了的lifetime变成了不同的lifetime</li>
<li>如果有明确指定的输入lifetime，这个lifetime会被指派给这个函数所有的省略lifetime的返回值</li>
<li>如果有多个输入的lifetime，但其中一个是&amp;self或者&amp;mut self，那么这个self的lifetime将会被指派给所有省略lifetime的返回值</li>
</ol>
<p>其他所有情况，省略一个返回值的lifetime都会报错</p>
<p>ps<br>这里要稍微吐槽一下rust，为了防止数据被多线程更改所以搞了一个所有权概念，为了有利于更改搞了一个borrow，为了保证更改完了不会被data race又搞了一个lifetime，真是越来越复杂呢。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/20/learning-rust-part-V/" data-id="cicfw51qh0012qtv42dardwm5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-IV" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/20/learning-rust-part-IV/" class="article-date">
  <time datetime="2015-07-20T06:25:13.000Z" itemprop="datePublished">2015-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/20/learning-rust-part-IV/">rust学习笔记(四)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基本语法">基本语法</h1><h2 id="变量绑定">变量绑定</h2><p>let 用于绑定变量，rust会自动推断类型名字，也可以自己指定类型，例如：</p>
<pre><code><span class="tag">let</span> <span class="rule"><span class="attribute">x</span>:<span class="value"> i32 = <span class="number">5</span></span></span>;
</code></pre><p>但是要注意的是所有变量初始化以后都是immutable的，需要添加mut才能改变变量的值。</p>
<pre><code><span class="keyword">let</span> mut <span class="variable">x=</span><span class="number">5</span>;
<span class="variable">x=</span><span class="number">10</span>;
</code></pre><p>不初始化的变量能过编译(会warning)，不能执行(报错)。</p>
<h2 id="函数">函数</h2><p>fn用于定义函数，基本格式如下：</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="keyword">i32</span>, y: <span class="keyword">i32</span>)-&gt;<span class="keyword">i32</span>{
}
</code></pre><p>参数后的类型指定了参数的类型，函数定义后的-&gt;代表了返回类型，函数的最后一行的结果决定了他返回什么值，所以这个返回值要符合返回值类型，并且不需要分号(;)结尾。<br>rust也支持return返回值，但不这么推荐。</p>
<h2 id="原始类型">原始类型</h2><p>rust里的primitive类型有这几个，boolean, char, numeric(i8, i16, i32, i64, u8, u16, u32, u64, isize, usize, f32, f64)</p>
<h2 id="数组">数组</h2><pre><code><span class="keyword">let</span> <span class="variable">a=</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];
<span class="keyword">let</span> mut <span class="variable">m=</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];
</code></pre><p>数组的类型是[T;N], T代表通用类型，N是数组长度，编译时决定。</p>
<p>利用这个也能初始化数组，比如</p>
<p>let a=[0;20]</p>
<p>就是20个0组成的数组。</p>
<h2 id="切片">切片</h2><p>数组能切片，比如</p>
<pre><code><span class="keyword">let</span> <span class="variable">a=</span>[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
<span class="keyword">let</span> <span class="variable">middle=</span>&amp;a[<span class="number">1</span>..<span class="number">4</span>];
<span class="keyword">let</span> <span class="variable">complete=</span>&amp;a[..];
</code></pre><h2 id="字符串">字符串</h2><p>字符串类型 str</p>
<h2 id="tuple">tuple</h2><p>rust里的tuple和python的一样</p>
<pre><code><span class="keyword">let</span> <span class="variable">x=</span>(<span class="number">1</span>,<span class="string">"hello"</span>);
</code></pre><p>定义只有一个值的tuple也需要加一个,</p>
<p>取值可以用下标</p>
<pre><code><span class="keyword">let</span> <span class="variable">a=</span> x.<span class="number">0</span>;
<span class="keyword">let</span> <span class="variable">b=</span> x.<span class="number">1</span>;
</code></pre><h2 id="函数-1">函数</h2><p>函数也有类型</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> {x}

<span class="keyword">let</span> x: <span class="function"><span class="keyword">fn</span></span>(<span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> = foo;
</code></pre><p>这种情况下x就是一个函数指针指向一个需要i32参数返回一个i32值的函数</p>
<h1 id="注释">注释</h1><p>注释之前已经说过了，这里就不说了。</p>
<h1 id="if">if</h1><p>rust里的if可以当做传统方法写</p>
<pre><code><span class="keyword">let</span> <span class="variable">x =</span> <span class="number">5</span>;

<span class="keyword">if</span> <span class="variable">x =</span>= <span class="number">5</span> {
    println!(<span class="string">"x is five!"</span>);
} <span class="keyword">else</span> {
    println!(<span class="string">"x is not five :("</span>);
}
</code></pre><p>也可以用函数式的方法写，推荐这么写：</p>
<pre><code><span class="keyword">let</span> <span class="variable">x =</span> <span class="number">5</span>;

<span class="keyword">let</span> <span class="variable">y =</span> <span class="keyword">if</span> <span class="variable">x =</span>= <span class="number">5</span> { <span class="number">10</span> } <span class="keyword">else</span> { <span class="number">15</span> };
</code></pre><p>当然这种写法就必须保证if有else 分支，并且每个分支的返回类型相同。</p>
<h2 id="for循环">for循环</h2><p>rust里的for循环也和python有点像:</p>
<pre><code><span class="keyword">for</span> <span class="keyword">var</span> <span class="keyword">in</span> expression{
    code
}
</code></pre><p>这个expression应该是一个迭代器(iterator)</p>
<h2 id="while循环">while循环</h2><p>rust也有while循环</p>
<pre><code><span class="keyword">let</span> mut x = <span class="number">5</span>; <span class="comment">// mut x: i32</span>
<span class="keyword">let</span> mut <span class="keyword">done</span> = <span class="keyword">false</span>; <span class="comment">// mut done: bool</span>

<span class="keyword">while</span> !<span class="keyword">done</span> {
    x += x - <span class="number">3</span>;

    println!(<span class="string">"{}"</span>, x);

    <span class="keyword">if</span> x % <span class="number">5</span> == <span class="number">0</span> {
        <span class="keyword">done</span> = <span class="keyword">true</span>;
    }
}
</code></pre><p>在循环里也可以用continue和break，用法同python</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/20/learning-rust-part-IV/" data-id="cicfw51qn0016qtv4s2nkzie2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-III" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/17/learning-rust-part-III/" class="article-date">
  <time datetime="2015-07-17T07:38:28.000Z" itemprop="datePublished">2015-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/17/learning-rust-part-III/">rust学习笔记(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="迭代器(Iterator)">迭代器(Iterator)</h2><p>rust带了迭代器，而其似乎特别推崇使用迭代器(这点倒是和python很像)，例如：</p>
<pre><code><span class="keyword">let</span> nums = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..nums.len() {
    <span class="built_in">println!</span>(<span class="string">"{}"</span>, nums[i]);
}
</code></pre><p>这种写法远比</p>
<pre><code><span class="keyword">let</span> nums = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="keyword">for</span> num <span class="keyword">in</span> &amp;nums {
    <span class="built_in">println!</span>(<span class="string">"{}"</span>, num);
}
</code></pre><p>要差，原因有二，1,第二种更直观，2,第二种不需要做数组的边界检查。与之相关的概念还有两个，迭代器适配器以及消费者，先讲消费者</p>
<h2 id="消费者(Consumer)">消费者(Consumer)</h2><p>消费者很简单，就是一个collect()，collect消费迭代器产生的数据返回一个集合，例如</p>
<pre><code><span class="keyword">let</span> <span class="variable">one_to_one_hundred =</span> (<span class="number">1</span>..<span class="number">101</span>).collect();
</code></pre><p>但这个代码是有问题的，因为collect不知道返回什么样的集合，例如，在以下例子中</p>
<pre><code><span class="keyword">let</span> x = <span class="string">"hello"</span>.chars<span class="literal">()</span>.rev<span class="literal">()</span>.collect<span class="literal">()</span>;
</code></pre><p>编译器不知道是应该返回char组成的数组Vec<char>还是一个字符串String，为了避免这种情况的发生，就必须用指定一下类型。</char></p>
<pre><code>let x = <span class="string">"hello"</span>.chars().rev().<span class="symbol">collect:</span><span class="symbol">:&lt;Vec&lt;char&gt;&gt;</span>();
let one_to_one_hundred = (<span class="number">1</span>..<span class="number">101</span>).<span class="symbol">collect:</span><span class="symbol">:&lt;Vec&lt;u32&gt;&gt;</span>();
</code></pre><p>也可以这么写</p>
<pre><code>let <span class="symbol">x:</span> <span class="constant">Vec&lt;</span>char&gt; = <span class="string">"hello"</span>.chars().rev().<span class="symbol">collect:</span><span class="symbol">:&lt;Vec&lt;char&gt;&gt;</span>();
let one_to_one_hundred = (<span class="number">1</span>..<span class="number">101</span>).<span class="symbol">collect:</span><span class="symbol">:&lt;Vec&lt;_&gt;&gt;</span>();
</code></pre><p>find也是一种消费者，拿一个匿名函数，返回一个Option，Option里面可能有东西Some(_)，也可能什么都没有(None)，这里看着好像haskell里的Maybe，果然好东西大家都会拿来用。</p>
<pre><code><span class="keyword">let</span> greater_than_forty_two = (<span class="number">0.</span>.<span class="number">100</span>)
                             .find(|x| *x &gt; <span class="number">42</span>);

<span class="keyword">match</span> greater_than_forty_two {
    <span class="type">Some</span>(_) =&gt; println!(<span class="string">"We got some numbers!"</span>),
    <span class="type">None</span> =&gt; println!(<span class="string">"No numbers found :("</span>),
}
</code></pre><p>fold也是一种消费者，需要两个参数，第一个是累加器(accumulator)，第二个是闭包</p>
<pre><code><span class="keyword">let</span> <span class="keyword">sum</span> <span class="subst">=</span> (<span class="number">1.</span><span class="built_in">.</span><span class="number">4</span>)<span class="built_in">.</span>fold(<span class="number">0</span>, <span class="subst">|</span><span class="keyword">sum</span>, x<span class="subst">|</span> <span class="keyword">sum</span> <span class="subst">+</span> x);
</code></pre><p>累加器的初始值是0,闭包的参数是sum和x，闭包内容就是sum+x，sum的初始值是0,x从迭代器里获取值。</p>
<h2 id="迭代器适配器">迭代器适配器</h2><p>最简单的迭代器适配器就是map了，从一个迭代器出发，通过对每个迭代器施加一个函数(闭包)获取另一个迭代器。但是要注意，大多数迭代器适配器都是懒惰的，他们不会主动求值</p>
<pre><code>(<span class="number">1</span>..<span class="number">100</span>).map(|x| x + <span class="number">1</span>);

 <span class="number">18</span>:<span class="number">29</span> warning: unused <span class="literal">result</span> which must be used: <span class="keyword">iterator</span> adaptors are lazy <span class="keyword">and</span> <span class="keyword">do</span> nothing unless consumed, <span class="comment">#[warn(unused_must_use)] on by default</span>
    (<span class="number">1</span>..<span class="number">100</span>).map(|x| x + <span class="number">1</span>);
</code></pre><p>take也是一种适配器</p>
<pre><code>(<span class="number">1</span>..).<span class="function"><span class="title">take</span><span class="params">(<span class="number">5</span>)</span></span>
</code></pre><p>filter也是一种适配器</p>
<pre><code>(<span class="number">1</span>..<span class="number">100</span>).<span class="function"><span class="title">filter</span><span class="params">(|&amp;x| x % <span class="number">2</span> == <span class="number">0</span>)</span></span>
</code></pre><p>值得注意的是，所有的适配器都不会主动求值，包括有副作用的函数，比如</p>
<pre><code>(<span class="number">1.</span>.<span class="number">100</span>).<span class="keyword">map</span>(|x| <span class="built_in">println</span>!(<span class="string">"{}"</span>, x));
</code></pre><p>如果想要他们主动求值，必须套在for里面</p>
<pre><code>for i in (<span class="number">1</span>..<span class="number">100</span>).map(|x| println!(<span class="string">"{}"</span>, x)).take(<span class="number">5</span>){
    println!(<span class="string">"a"</span>)<span class="comment">;</span>
}
<span class="number">1</span>
<span class="literal">a</span>
<span class="number">2</span>
<span class="literal">a</span>
<span class="number">3</span>
<span class="literal">a</span>
<span class="number">4</span>
<span class="literal">a</span>
<span class="number">5</span>
<span class="literal">a</span>
</code></pre><p>这点和haskell很不一样(也有可能我记错了)</p>
<h2 id="并发(Concurrency)">并发(Concurrency)</h2><p>并发这一块暂时没看懂回头再来补</p>
<h2 id="错误处理">错误处理</h2><p>rust有两种错误，一种叫做failure，一种叫做panic。前者可以通过代码处理继续运行，而后者则直接停止程序运行。例如</p>
<pre><code><span class="preprocessor">#[derive(Debug)]</span>
<span class="keyword">enum</span> <span class="title">Version</span>{Version1, Version2}

<span class="preprocessor">#[derive(Debug)]</span>
<span class="keyword">enum</span> <span class="title">ParseError</span>{InvalidHeaderLength, InvalidVersion}

<span class="function"><span class="keyword">fn</span> <span class="title">parse_version</span></span>(header: &amp;[<span class="keyword">u8</span>])-&gt;Result&lt;Version, ParseError&gt;{
    <span class="keyword">if</span> header.len()&lt;<span class="number">1</span>{
        <span class="keyword">return</span> Err(ParseError::InvalidHeaderLength);
    }
    <span class="keyword">match</span> header[<span class="number">0</span>]{
        <span class="number">1</span>=&gt;Ok(Version::Version1),
        <span class="number">2</span>=&gt;Ok(Version::Version2),
        _=&gt;Err(ParseError::InvalidVersion)
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(){

    <span class="keyword">let</span> version=parse_version(&amp;[<span class="number">3</span>]);
    <span class="keyword">match</span> version{
        Ok(v)=&gt;{
            <span class="built_in">println!</span>(<span class="string">"working with version: {:?}"</span>,v);
        }
        Err(e)=&gt;{
            <span class="built_in">println!</span>(<span class="string">"error parsing header: {:?}"</span>,e);
        }
    }
    <span class="keyword">let</span> version=parse_version(&amp;[<span class="number">1</span>]);
    <span class="keyword">for</span> i <span class="keyword">in</span> version
    <span class="keyword">match</span> version{
        Ok(v)=&gt;{
            <span class="built_in">println!</span>(<span class="string">"working with version: {:?}"</span>,v);
        }
        Err(e)=&gt;{
            <span class="built_in">println!</span>(<span class="string">"error parsing header: {:?}"</span>,e);
        }
    }
}
</code></pre><p>这里就是普通的failure，对于panic，我们之前已经用到的unwrap产生的就是panic，事实上unwrap的工作就是将failure处理(upgrade)为panic。例如</p>
<pre><code><span class="rule"><span class="attribute">io</span>:<span class="value">:<span class="function">stdin</span>().<span class="function">read_line</span>(&amp;mut buffer).<span class="function">unwrap</span>()</span></span>;
</code></pre><p>unwrap的意思就是如果碰到OK就通过，但碰到Err就报错退出。</p>
<p>let mut buffer = String::new();<br>let input = io::stdin().read_line(&amp;mut buffer)<br>                       .ok()<br>                       .expect(“Failed to read line”);</p>
<p>这里用ok更优美点，ok将Result转化为Option，如果发生None，那打印expect的参数退出。expect做的事情很unwrap差不多。</p>
<p>对于函数的错误还有try!这个宏，但是try!这个宏只能在返回Result类型的函数内使用，try失败就返回一个Result类型了，所以main中不能使用try，因为main的返回值不是Result。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/17/learning-rust-part-III/" data-id="cicfw51qo0018qtv4igca32u5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-II" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/17/learning-rust-part-II/" class="article-date">
  <time datetime="2015-07-17T03:04:24.000Z" itemprop="datePublished">2015-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/17/learning-rust-part-II/">rust学习笔记(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="多线程">多线程</h2><p>继续学习rust，今天看的是一个怎么利用rust写多线程的例子。这个问题叫做哲学家吃饭，一张圆桌子五个哲学家，每人吃饭都要先拿起左手的筷子再拿右手的筷子，吃完放回去。但如果统一拿左手的筷子，必然会发生线程死锁:每个人都拿了左手的筷子并且等右手的筷子。</p>
<pre><code><span class="keyword">use</span> std::thread;<span class="comment">//引入线程</span>
<span class="keyword">use</span> std::sync::{Mutex, Arc};<span class="comment">//引入锁和原子操作</span>

<span class="keyword">struct</span> Table{
    forks: Vec&lt;Mutex&lt;()&gt;&gt;,<span class="comment">//这是个锁组成的数组，数组的每个元素代表一双筷子</span>
}

<span class="keyword">struct</span> Philosopher{
    name: String,
    left: usize,<span class="comment">//哲学家的左右手代表了锁在数组中的相应位置</span>
    right: usize,
}

<span class="keyword">impl</span> Philosopher{
    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="keyword">str</span>, left: usize, right: usize)-&gt;Philosopher{
        Philosopher{
            name :name.to_string(),
            left: left,
            right: right,
        }
    }
    <span class="function"><span class="keyword">fn</span> <span class="title">eat</span></span>(&amp;<span class="keyword">self</span>, table: &amp;Table){
        <span class="keyword">let</span> _left = table.forks[<span class="keyword">self</span>.left].lock().unwrap();<span class="comment">//获取锁，_left前的_代表不对起不使用进行报警</span>
        <span class="keyword">let</span> _right=table.forks[<span class="keyword">self</span>.right].lock().unwrap();<span class="comment">//unwrap代表当获取锁失败时无视失败，并且将failure变成panic!</span>
        <span class="built_in">println!</span>(<span class="string">"{} is eating."</span>,<span class="keyword">self</span>.name);
        thread::sleep_ms(<span class="number">1000</span>);
        <span class="built_in">println!</span>(<span class="string">"{} is done eating."</span>, <span class="keyword">self</span>.name);
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> table = Arc::new(Table {forks: <span class="built_in">vec!</span>[
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            ]});<span class="comment">//(Table {...})是建立了一个Table对象，由于我们没有给Table绑一个new函数所以需要这种方法新建对象。</span>
            <span class="comment">//Arc(Atomic reference count)代表这个Table是支持原子引用计数的，每在一个线程中分享，就加一，这个线程退出就减一。</span>

    <span class="keyword">let</span> philosophers=<span class="built_in">vec!</span>[
        Philosopher::new(<span class="string">"Baruch Spinoza"</span>,<span class="number">0</span>,<span class="number">1</span>),
        Philosopher::new(<span class="string">"Gilles Deleuze"</span>,<span class="number">1</span>,<span class="number">2</span>),
        Philosopher::new(<span class="string">"Karl Marx"</span>,<span class="number">2</span>,<span class="number">3</span>),
        Philosopher::new(<span class="string">"Friedrich Nietzsche"</span>,<span class="number">3</span>,<span class="number">4</span>),
        Philosopher::new(<span class="string">"Michel Foucault"</span>,<span class="number">0</span>,<span class="number">4</span>),<span class="comment">//防止死锁的小技巧，先获取0再获取4</span>
    ];
    <span class="keyword">let</span> handles: Vec&lt;_&gt;=philosophers.into_iter().map(|p|{<span class="comment">//into_iter将数组转换为迭代器(iterator)</span>
            <span class="keyword">let</span> table = table.clone();<span class="comment">//这里将原始引用复制一份</span>
            thread::spawn(move||{<span class="comment">//起一个线程执行对应的p.eat, move用于维持闭包，获得eat的返回值</span>
                p.eat(&amp;table);
                })}).collect();
    <span class="keyword">for</span> h <span class="keyword">in</span> handles{
        h.join().unwrap();<span class="comment">//等每个线程结束</span>
    }
}
</code></pre><h2 id="FFI">FFI</h2><p>rust还很好的支持了FFI(foreign function interface)，能够在别的语言中调用rust写的库，例如<br>新建一个项目</p>
<pre><code><span class="variable">$ </span>cargo new embed
<span class="variable">$ </span>cd embed
</code></pre><p>里面填这些代码</p>
<pre><code><span class="keyword">use</span> std::thread;

<span class="preprocessor">#[no_mangle]</span><span class="comment">//产生外部能辨认的symbol</span>
<span class="keyword">pub</span> <span class="keyword">extern</span> <span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(){<span class="comment">//pub 和extern代表将process函数公开，外部可调用</span>
    <span class="keyword">let</span> handles: Vec&lt;_&gt;=(<span class="number">0</span>..<span class="number">10</span>).map(|_|{
        thread::spawn(||{
            <span class="keyword">let</span> <span class="keyword">mut</span> _x=<span class="number">0</span>;
            <span class="keyword">for</span> _ <span class="keyword">in</span> (<span class="number">0</span>..<span class="number">5_000_001</span>){
                _x+=<span class="number">1</span>
            }
        })
    }).collect();
    <span class="keyword">for</span> h <span class="keyword">in</span> handles{
        h.join().ok().expect(<span class="string">"Could not join a thread!"</span>);
    }
}
</code></pre><p>更改配置文件</p>
<pre><code>vi Cargo.toml
[lib]
name = <span class="string">"embed"</span>
<span class="keyword">crate</span>-<span class="keyword">type</span> = [<span class="string">"dylib"</span>]<span class="comment">//标准动态链接库，不然默认是rlib</span>
</code></pre><p>编译</p>
<pre><code>$ cargo build <span class="comment">--release</span>
</code></pre><p>python中调用</p>
<pre><code>from ctypes import cdll
lib = cdll.<span class="function"><span class="title">LoadLibrary</span><span class="params">(<span class="string">"target/release/libembed.so"</span>)</span></span>
lib.<span class="function"><span class="title">process</span><span class="params">()</span></span>
<span class="function"><span class="title">print</span><span class="params">(<span class="string">"done!"</span>)</span></span>
</code></pre><h2 id="测试">测试</h2><p>大致看了一下rust里的测试部分，感觉做的还很贴心方便，和python里的unittest不一样的是，rust直接将测试整合了进来，一共三种测试：和每个function一起的单元测试，整合（integration）测试，文档测试。</p>
<pre><code><span class="variable">$ </span>cargo new adder
<span class="variable">$ </span>cd adder
</code></pre><p>打开src/lib.rs</p>
<pre><code><span class="comment">//! The `adder` crate provides functions that add numbers to other numbers.</span>
<span class="comment">//!</span>
<span class="comment">//! # Examples</span>
<span class="comment">//!</span>
<span class="comment">//! <figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//<span class="exclamation_mark">!</span> <span class="function_or_atom">assert_eq</span><span class="exclamation_mark">!</span>(<span class="number">4</span>, <span class="function_or_atom">adder</span>::<span class="function_or_atom">add_two</span>(<span class="number">2</span>));</span><br><span class="line">//<span class="exclamation_mark">!</span></span><br></pre></td></tr></table></figure></span>


<span class="comment">/// This function adds two to its argument.</span>
<span class="comment">///</span>
<span class="comment">/// # Examples</span>
<span class="comment">///</span>
<span class="comment">/// <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// use adder::add_two;</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(4, add_two(2));</span></span><br><span class="line"><span class="comment">///</span></span><br></pre></td></tr></table></figure></span>

<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_two</span></span>(a:<span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span>{
    a+<span class="number">2</span>
}

<span class="preprocessor">#[cfg(test)]</span>
<span class="keyword">mod</span> tests {
    <span class="keyword">use</span> super::*;

    <span class="preprocessor">#[test]</span>
    <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() {  
        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, add_two(<span class="number">2</span>));
    }
}
</code></pre><p>斜杠开头的那几行是文档测试，测试内容用<code>xxxx</code>包围起来，支持markdown。///开头的是函数级别的测试，//!是模块级别的测试。#[cfg(test)]那里是单元测试。可以很方便的写一些辅助函数帮助测试，在非cargo test的时候这一部分代码不会编译。还有一种就是另建一个tests目录，tests/lib.rs，做整合测试。</p>
<pre><code><span class="keyword">extern</span> <span class="keyword">crate</span> adder;

<span class="preprocessor">#[test]</span>
<span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>(){
    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::add_two(<span class="number">2</span>));
}
</code></pre><h2 id="条件编译">条件编译</h2><p>rust也支持条件编译，例如</p>
<pre><code>#[<span class="function"><span class="title">cfg</span><span class="params">(foo)</span></span>]

#[<span class="function"><span class="title">cfg</span><span class="params">(bar = <span class="string">"baz"</span>)</span></span>]

#[<span class="function"><span class="title">cfg</span><span class="params">(any(unix, windows)</span></span>)]

#[<span class="function"><span class="title">cfg</span><span class="params">(all(unix, target_pointer_width = <span class="string">"32"</span>)</span></span>)]

#[<span class="function"><span class="title">cfg</span><span class="params">(not(foo)</span></span>)]
</code></pre><p>在函数定义的上一行写下这些字段，能帮助cargo决定这个函数是不是要在当前条件下编译。<br>在Cargo.toml中</p>
<pre><code>[features]
<span class="preprocessor"># no features by default</span>
<span class="default"><span class="keyword">default</span> = []</span>
</code></pre><h2 id="文档">文档</h2><p>刚才已经提到过，需要用///来注释文档，但需要注意的是，文档需要写成这样</p>
<pre><code><span class="dartdoc"><span class="markdown">/// The <span class="code">`Option`</span> type. See [<span class="link_label">the module level documentation</span>](<span class="link_url">../</span>) for more.</span></span>
<span class="keyword">enum</span> Option&lt;T&gt; {
    <span class="dartdoc"><span class="markdown">/// No value</span></span>
    None,
    <span class="dartdoc"><span class="markdown">/// Some value <span class="code">`T`</span></span></span>
    Some(T),
}
</code></pre><p>而不是这样</p>
<pre><code><span class="dartdoc"><span class="markdown">/// The <span class="code">`Option`</span> type. See [<span class="link_label">the module level documentation</span>](<span class="link_url">../</span>) for more.</span></span>
<span class="keyword">enum</span> Option&lt;T&gt; {
    None, <span class="dartdoc"><span class="markdown">/// No value</span></span>
    Some(T), <span class="dartdoc"><span class="markdown">/// Some value <span class="code">`T`</span></span></span>
}
</code></pre><p>使用</p>
<pre><code><span class="title">cargo</span> doc
</code></pre><p>生成文档</p>
<p>大致了解了一下，接下去继续看详细的语法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/17/learning-rust-part-II/" data-id="cicfw51qq001aqtv4npe9e8g2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning-rust-part-I" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/16/learning-rust-part-I/" class="article-date">
  <time datetime="2015-07-16T01:49:38.000Z" itemprop="datePublished">2015-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/16/learning-rust-part-I/">rust学习笔记(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>rust今年来发布了1.0版本，很火，一直想学可惜一直太懒，最近有空正好学习一下，写一点笔记。<br>初次关注rust的时候还是1.0版本，等到现在想学了，已经是1.1版本了……所以我是有多懒惰啊。  </p>
<h2 id="安装">安装</h2><pre><code>$ curl -<span class="keyword">sf</span> -L http<span class="variable">s:</span>//static.rust-lang.org/rustup.<span class="keyword">sh</span> | <span class="keyword">sh</span>
</code></pre><h2 id="卸载">卸载</h2><pre><code>$ sudo <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>rustlib<span class="regexp">/uninstall.sh</span>
</code></pre><p>rust自带一个叫做cargo的项目管理器，可以很方便的新建、编译、运行项目</p>
<h2 id="新建">新建</h2><pre><code><span class="variable">$ </span>cargo new hello_world --bin
<span class="variable">$ </span>cd hello_world
</code></pre><h2 id="编译">编译</h2><pre><code><span class="variable">$ </span>cargo build
</code></pre><h2 id="运行">运行</h2><pre><code>$ cargo <span class="command">run</span>
</code></pre><p>新建一个项目以后，这个项目的目录下会有一个Cargo.toml的文件，对项目内容做了一些必要的描述，例如，版本号，名字。rust和c++/c一样，需要编译运行。所以导入一些依赖库需要在Cargo.toml中指明，例如</p>
<pre><code><span class="title">[dependencies]</span>

<span class="setting">rand=<span class="value"><span class="string">"0.3.0"</span></span></span>
</code></pre><p>cargo会自动去github上寻找这个包在编译时链接。以下贴一个官方的例子简要介绍rust的语法</p>
<pre><code><span class="keyword">extern</span> <span class="keyword">crate</span> rand; <span class="comment">//指明rand是一个外部包，crate在rust中即包</span>

<span class="keyword">use</span> std::io; <span class="comment">//指明需要使用的库</span>
<span class="keyword">use</span> std::cmp::Ordering;
<span class="keyword">use</span> rand::Rng;

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() { <span class="comment">//定义一个main函数，fn是定义函数的关键字</span>
    <span class="built_in">println!</span>(<span class="string">"Guess the number!"</span>);<span class="comment">//println!是宏</span>

    <span class="keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="number">1</span>, <span class="number">101</span>);<span class="comment">//let是一个绑定，将secret_number绑定到随机数上，rust里默认的变量是不可变的</span>

    <span class="keyword">loop</span> {<span class="comment">//loop代表一个循环</span>
        <span class="built_in">println!</span>(<span class="string">"Please input your guess."</span>);

        <span class="keyword">let</span> <span class="keyword">mut</span> guess = String::new();<span class="comment">//mut代表将guess设定为mutable(可变的)</span>

        io::stdin().read_line(&amp;<span class="keyword">mut</span> guess)<span class="comment">//这里&amp;guess代表的是guess的reference，默认是不可变的，但mut指定为可变（我在想是不是其实就是读了一个字符串得到一个指向这个字符串的地址A，然后直接将A复制到guess这个指针所在的地址，相当于将guess指向了另一个字符串。）</span>
            .ok()<span class="comment">//io会返回io::Result，必须写代码处理，不然编译器会鄙视你，这里ok代表io成功运行什么代码</span>
            .expect(<span class="string">"failed to read line"</span>);<span class="comment">//ok也会返回一个需要处理的值需要expect处理，如果失败就打印这句话并退出</span>

        <span class="keyword">let</span> guess: <span class="keyword">u32</span> = <span class="keyword">match</span> guess.trim().parse() {<span class="comment">//字符转换成数字，并对结果进行模式匹配</span>
            Ok(num) =&gt; num,<span class="comment">//如果成功，就返回数值</span>
            Err(_) =&gt; <span class="keyword">continue</span>,<span class="comment">//如果失败就继续，不出错</span>
        };

        <span class="built_in">println!</span>(<span class="string">"You guessed: {}"</span>, guess);

        <span class="keyword">match</span> guess.cmp(&amp;secret_number) {<span class="comment">//guess和secret_number进行比较，并且进行模式匹配</span>
            Ordering::Less    =&gt; <span class="built_in">println!</span>(<span class="string">"Too small!"</span>),
            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">"Too big!"</span>),
            Ordering::Equal   =&gt; {
                <span class="built_in">println!</span>(<span class="string">"You win!"</span>);
                <span class="keyword">break</span>;<span class="comment">//退出循环</span>
            }
        }
    }
}
</code></pre><p>这是官方教程的第一个例子。来一个复杂一点的</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="built_in">vec!</span>[<span class="string">"Hello"</span>, <span class="string">"world"</span>];

    <span class="keyword">let</span> y = &amp;x[<span class="number">0</span>];

    x.push(<span class="string">"foo"</span>);
}
</code></pre><p>这段代码会报错</p>
<pre><code>src/main.<span class="string">rs:</span><span class="number">6</span>:<span class="number">5</span>: <span class="number">6</span>:<span class="number">6</span> <span class="string">error:</span> cannot borrow `x` <span class="keyword">as</span> mutable because it is also borrowed <span class="keyword">as</span> immutable
src/main.<span class="string">rs:</span><span class="number">6</span>     x.push(<span class="string">"foo"</span>);
                  ^
src/main.<span class="string">rs:</span><span class="number">4</span>:<span class="number">14</span>: <span class="number">4</span>:<span class="number">15</span> <span class="string">note:</span> previous borrow of `x` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `x` until the borrow ends
src/main.<span class="string">rs:</span><span class="number">4</span>     let y = &amp;x[<span class="number">0</span>];
                           ^
src/main.<span class="string">rs:</span><span class="number">7</span>:<span class="number">2</span>: <span class="number">7</span>:<span class="number">2</span> <span class="string">note:</span> previous borrow ends here
src/main.<span class="string">rs:</span><span class="number">1</span> fn main() {
...
src/main.<span class="string">rs:</span><span class="number">7</span> }
</code></pre><p>大意就是 x的第一个元素被immutable的引用了一次，所以x就不能被更改，如果我们把他的引用改为mutable呢？</p>
<pre><code>src/main.<span class="string">rs:</span><span class="number">6</span>:<span class="number">5</span>: <span class="number">6</span>:<span class="number">6</span> <span class="string">error:</span> cannot borrow `x` <span class="keyword">as</span> mutable more than once at a time
src/main.<span class="string">rs:</span><span class="number">6</span>     x.push(<span class="string">"foo"</span>);
                  ^
src/main.<span class="string">rs:</span><span class="number">4</span>:<span class="number">19</span>: <span class="number">4</span>:<span class="number">20</span> <span class="string">note:</span> previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends
src/main.<span class="string">rs:</span><span class="number">4</span>     let y = &amp; mut x[<span class="number">0</span>];
                                ^
src/main.<span class="string">rs:</span><span class="number">7</span>:<span class="number">2</span>: <span class="number">7</span>:<span class="number">2</span> <span class="string">note:</span> previous borrow ends here
src/main.<span class="string">rs:</span><span class="number">1</span> fn main() {
...
src/main.<span class="string">rs:</span><span class="number">7</span> }
</code></pre><p>又报错了，说x不能被多次mutable引用<br>所以rust通过控制引用的可变和不可变以及可变应用次数来达到不需要gc也能自动释放占用内存。要想达到刚才的效果，只能这么做。</p>
<pre><code><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="built_in">vec!</span>[<span class="string">"Hello"</span>, <span class="string">"world"</span>];

    <span class="keyword">let</span> y = x[<span class="number">0</span>].clone();

    x.push(<span class="string">"foo"</span>);
}

或者

<span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {
    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="built_in">vec!</span>[<span class="string">"Hello"</span>, <span class="string">"world"</span>];

    {
        <span class="keyword">let</span> y = &amp;x[<span class="number">0</span>];
    }

    x.push(<span class="string">"foo"</span>);
}
</code></pre><p>前者给y做了一个x的备份，这样很自然的就将同一内存的操作分开了。后者在一个scope内新建了一个引用，离开这个scope这个引用就消失了，所以也能对x进行可变操作。<br>先写到这里，继续看书明天更新</p>
<h2 id="参考">参考</h2><p><a href="https://doc.rust-lang.org/stable/book/hello-cargo.html" target="_blank" rel="external">https://doc.rust-lang.org/stable/book/hello-cargo.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/16/learning-rust-part-I/" data-id="cicfw51qs001cqtv40y1dgerv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-explore-spark-distributed-mllib" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/21/explore-spark-distributed-mllib/" class="article-date">
  <time datetime="2015-06-21T04:26:50.000Z" itemprop="datePublished">2015-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/21/explore-spark-distributed-mllib/">spark的mllib到底是不是分布式的</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>端午节，群里有个人问了一个spark关于mllib扩展性的问题，不太确定，继续看代码。正好上周1.4也发布了，也把代码下下来比较了一下。<br>比较以后才知道，原来scala版本的计算和pyspark差了好多，pyspark关于linalg的计算都是直接调用numpy，也就是非并行的。例如linalg.py里随处可见的np.dot</p>
<pre><code>assert <span class="function"><span class="title">len</span><span class="params">(self)</span></span> == other<span class="class">.shape</span>[<span class="number">0</span>], <span class="string">"dimension mismatch"</span>
             return other.<span class="function"><span class="title">transpose</span><span class="params">()</span></span>.<span class="function"><span class="title">dot</span><span class="params">(self.toArray()</span></span>)
         <span class="keyword">else</span>:
             assert <span class="function"><span class="title">len</span><span class="params">(self)</span></span> == _vector_size(other), <span class="string">"dimension mismatch"</span>
             <span class="keyword">if</span> <span class="function"><span class="title">isinstance</span><span class="params">(other, SparseVector)</span></span>:
                 return other.<span class="function"><span class="title">dot</span><span class="params">(self)</span></span>
             elif <span class="function"><span class="title">isinstance</span><span class="params">(other, Vector)</span></span>:
                 return np.<span class="function"><span class="title">dot</span><span class="params">(self.toArray()</span></span>, other.<span class="function"><span class="title">toArray</span><span class="params">()</span></span>)
             <span class="keyword">else</span>:
                 return np.<span class="function"><span class="title">dot</span><span class="params">(self.toArray()</span></span>, other)
</code></pre><p>但scala版本的linalg多了一个distributed的目录，下面就定义了好几种分布式矩阵</p>
<pre><code>:~/spark-<span class="number">1.4</span>.<span class="number">0</span>$ ls mllib/src/<span class="keyword">main</span>/scala/org/apache/spark/mllib/linalg/distributed/*
mllib/src/<span class="keyword">main</span>/scala/org/apache/spark/mllib/linalg/distributed/<span class="constant">Block</span>Matrix.scala
mllib/src/<span class="keyword">main</span>/scala/org/apache/spark/mllib/linalg/distributed/<span class="constant">Coordinate</span>Matrix.scala
mllib/src/<span class="keyword">main</span>/scala/org/apache/spark/mllib/linalg/distributed/<span class="constant">Distributed</span>Matrix.scala
mllib/src/<span class="keyword">main</span>/scala/org/apache/spark/mllib/linalg/distributed/<span class="constant">Indexed</span>RowMatrix.scala
mllib/src/<span class="keyword">main</span>/scala/org/apache/spark/mllib/linalg/distributed/<span class="constant">Row</span>Matrix.scala
</code></pre><p>除此以外还多了SVD，PCA一些常见矩阵运算。当然，在linalg中的BLAS.scala里面，依旧是调用了本地的blas库来计算矩阵乘法</p>
<pre><code>private <span class="function"><span class="keyword">def</span> <span class="title">dot</span><span class="params">(x: DenseVector, y: DenseVector)</span>:</span> Double = {
  val n = x.size
  f2jBLAS.ddot(n, x.values, <span class="number">1</span>, y.values, <span class="number">1</span>)
}     
</code></pre><p>这里仅限于非稀疏矩阵，spark中所有的稀疏矩阵都是自己写的没有调用额外的库</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">dot</span>(</span>x: <span class="type">SparseVector</span>, y: <span class="type">SparseVector</span>): <span class="type">Double</span> = {
     <span class="function"><span class="keyword">val</span> <span class="title">xValues</span> =</span> x.values
     <span class="function"><span class="keyword">val</span> <span class="title">xIndices</span> =</span> x.indices
     <span class="function"><span class="keyword">val</span> <span class="title">yValues</span> =</span> y.values
     <span class="function"><span class="keyword">val</span> <span class="title">yIndices</span> =</span> y.indices
     <span class="function"><span class="keyword">val</span> <span class="title">nnzx</span> =</span> xIndices.size
     <span class="function"><span class="keyword">val</span> <span class="title">nnzy</span> =</span> yIndices.size

     <span class="keyword">var</span> kx = <span class="number">0</span>
     <span class="keyword">var</span> ky = <span class="number">0</span>
     <span class="keyword">var</span> sum = <span class="number">0.0</span>
     <span class="comment">// y catching x</span>
     <span class="keyword">while</span> (kx &lt; nnzx &amp;&amp; ky &lt; nnzy) {
       <span class="function"><span class="keyword">val</span> <span class="title">ix</span> =</span> xIndices(kx)
       <span class="keyword">while</span> (ky &lt; nnzy &amp;&amp; yIndices(ky) &lt; ix) {
         ky += <span class="number">1</span>
       }
       <span class="keyword">if</span> (ky &lt; nnzy &amp;&amp; yIndices(ky) == ix) {
         sum += xValues(kx) * yValues(ky)
         ky += <span class="number">1</span>
       }
       kx += <span class="number">1</span>
     }
     sum
   }
</code></pre><p>矩阵乘法也是一样处理，都是牵涉到稀疏矩阵计算的就用自己写的方法</p>
<pre><code>private def gemm(
       alpha: Double,
       A: DenseMatrix,
       B: DenseMatrix,
       beta: Double,
       C: DenseMatrix): <span class="variable">Unit =</span> {
     val <span class="variable">tAstr =</span> <span class="keyword">if</span> (A.isTransposed) <span class="string">"T"</span> <span class="keyword">else</span> <span class="string">"N"</span>
     val <span class="variable">tBstr =</span> <span class="keyword">if</span> (B.isTransposed) <span class="string">"T"</span> <span class="keyword">else</span> <span class="string">"N"</span>
     val <span class="variable">lda =</span> <span class="keyword">if</span> (!A.isTransposed) A.numRows <span class="keyword">else</span> A.numCols
     val <span class="variable">ldb =</span> <span class="keyword">if</span> (!B.isTransposed) B.numRows <span class="keyword">else</span> B.numCols

     require(A.<span class="variable">numCols =</span>= B.numRows,
       s<span class="string">"The columns of A don't match the rows of B. A: <span class="subst">${A.numCols}</span>, B: <span class="subst">${B.numRows}</span>"</span>)
     require(A.<span class="variable">numRows =</span>= C.numRows,
       s<span class="string">"The rows of C don't match the rows of A. C: <span class="subst">${C.numRows}</span>, A: <span class="subst">${A.numRows}</span>"</span>)
     require(B.<span class="variable">numCols =</span>= C.numCols,
       s<span class="string">"The columns of C don't match the columns of B. C: <span class="subst">${C.numCols}</span>, A: <span class="subst">${B.numCols}</span>"</span>)
     nativeBLAS.dgemm(tAstr, tBstr, A.numRows, B.numCols, A.numCols, alpha, A.values, lda,
       B.values, ldb, beta, C.values, C.numRows)
   }
</code></pre><p>然后，我们回到spark的分布式矩阵，分布式矩阵的好处是直接利用rdd就能将对应的值转化为矩阵，例如这样</p>
<pre><code>val rows = sc.textFile(args(<span class="number">0</span>)).<span class="built_in">map</span> { <span class="built_in">line</span> =&gt;
       val values = <span class="built_in">line</span>.<span class="built_in">split</span>(<span class="string">' '</span>).<span class="built_in">map</span>(_.toDouble)
       Vectors.dense(values)
     }
     val mat = <span class="keyword">new</span> RowMatrix(rows)
</code></pre><p>这样，mat就是一个分布式的RowMatrix了，所做的就是赋值一个rdd。对于做SVD这类计算来说，RowMatrix定义了三种方法LocalARPACK，LocalLAPACK和DistARPACK，根据m，n的大小来自动决定到底用哪个计算</p>
<pre><code><span class="keyword">if</span> (n &lt; <span class="number">100</span> || (k &gt; n / <span class="number">2</span> &amp;&amp; n &lt;= <span class="number">15000</span>)) {
          <span class="regexp">//</span> If n <span class="keyword">is</span> small <span class="keyword">or</span> k <span class="keyword">is</span> large compared <span class="reserved">with</span> n, we better compute the Gramian matrix first
          <span class="regexp">//</span> <span class="keyword">and</span> <span class="keyword">then</span> compute its eigenvalues locally, instead <span class="keyword">of</span> making multiple passes.
          <span class="keyword">if</span> (k &lt; n / <span class="number">3</span>) {
            SVDMode.LocalARPACK
          } <span class="keyword">else</span> {
            SVDMode.LocalLAPACK
          }
        } <span class="keyword">else</span> {
          <span class="regexp">//</span> If k <span class="keyword">is</span> small compared <span class="reserved">with</span> n, we use ARPACK <span class="reserved">with</span> distributed multiplication.
          SVDMode.DistARPACK
        }
</code></pre><p>基本上矩阵尺寸不大的时候就用local的方法来计算了，似乎作者认为ARPACK在计算方阵的时候效率不如lapack。所以当k&gt;n/3的时候选择了lapack。选完了以后就开始计算对角化矩阵</p>
<pre><code><span class="function"><span class="keyword">val</span> (</span>sigmaSquares: <span class="type">BDV</span>[<span class="type">Double</span>], u: <span class="type">BDM</span>[<span class="type">Double</span>]) = computeMode <span class="keyword">match</span> {
       <span class="keyword">case</span> <span class="type">SVDMode</span>.<span class="type">LocalARPACK</span> =&gt;
         require(k &lt; n, s<span class="string">"k must be smaller than n in local-eigs mode but got k=$k and n=$n."</span>)
         <span class="function"><span class="keyword">val</span> <span class="title">G</span> =</span> computeGramianMatrix().toBreeze.asInstanceOf[<span class="type">BDM</span>[<span class="type">Double</span>]]
         <span class="type">EigenValueDecomposition</span>.symmetricEigs(v =&gt; <span class="type">G</span> * v, n, k, tol, maxIter)
       <span class="keyword">case</span> <span class="type">SVDMode</span>.<span class="type">LocalLAPACK</span> =&gt;
         <span class="comment">// breeze (v0.10) svd latent constraint, 7 * n * n + 4 * n &lt; Int.MaxValue</span>
         require(n &lt; <span class="number">17515</span>, s<span class="string">"$n exceeds the breeze svd capability"</span>)
         <span class="function"><span class="keyword">val</span> <span class="title">G</span> =</span> computeGramianMatrix().toBreeze.asInstanceOf[<span class="type">BDM</span>[<span class="type">Double</span>]]
         <span class="function"><span class="keyword">val</span> <span class="title">brzSvd</span>.<span class="title">SVD</span>(</span>uFull: <span class="type">BDM</span>[<span class="type">Double</span>], sigmaSquaresFull: <span class="type">BDV</span>[<span class="type">Double</span>], _) = brzSvd(<span class="type">G</span>)
         (sigmaSquaresFull, uFull)
       <span class="keyword">case</span> <span class="type">SVDMode</span>.<span class="type">DistARPACK</span> =&gt;
         <span class="keyword">if</span> (rows.getStorageLevel == <span class="type">StorageLevel</span>.<span class="type">NONE</span>) {
           logWarning(<span class="string">"The input data is not directly cached, which may hurt performance if its"</span>
             + <span class="string">" parent RDDs are also uncached."</span>)
         }
         require(k &lt; n, s<span class="string">"k must be smaller than n in dist-eigs mode but got k=$k and n=$n."</span>)
         <span class="type">EigenValueDecomposition</span>.symmetricEigs(multiplyGramianMatrixBy, n, k, tol, maxIter)
         }
</code></pre><p>这里不管lapack怎么算（其实两者最后都是调用了brzSvd去计算的），ARPACK是调用了EigenValueDecomposition去计算的，并且要求一个Gramian矩阵</p>
<pre><code><span class="keyword">private</span>[mllib] <span class="function"><span class="keyword">def</span> <span class="title">multiplyGramianMatrixBy</span>(</span>v: <span class="type">BDV</span>[<span class="type">Double</span>]): <span class="type">BDV</span>[<span class="type">Double</span>] = {
     <span class="function"><span class="keyword">val</span> <span class="title">n</span> =</span> numCols().toInt
     <span class="function"><span class="keyword">val</span> <span class="title">vbr</span> =</span> rows.context.broadcast(v)
     rows.treeAggregate(<span class="type">BDV</span>.zeros[<span class="type">Double</span>](n))(
       seqOp = (<span class="type">U</span>, r) =&gt; {
         <span class="function"><span class="keyword">val</span> <span class="title">rBrz</span> =</span> r.toBreeze
         <span class="function"><span class="keyword">val</span> <span class="title">a</span> =</span> rBrz.dot(vbr.value)
         rBrz <span class="keyword">match</span> {
           <span class="comment">// use specialized axpy for better performance</span>
           <span class="keyword">case</span> _: <span class="type">BDV</span>[_] =&gt; brzAxpy(a, rBrz.asInstanceOf[<span class="type">BDV</span>[<span class="type">Double</span>]], <span class="type">U</span>)
           <span class="keyword">case</span> _: <span class="type">BSV</span>[_] =&gt; brzAxpy(a, rBrz.asInstanceOf[<span class="type">BSV</span>[<span class="type">Double</span>]], <span class="type">U</span>)
           <span class="keyword">case</span> _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnsupportedOperationException</span>(
             s<span class="string">"Do not support vector operation from type ${rBrz.getClass.getName}."</span>)
         }
         <span class="type">U</span>
       }, combOp = (<span class="type">U1</span>, <span class="type">U2</span>) =&gt; <span class="type">U1</span> += <span class="type">U2</span>)
   }
</code></pre><p>这个计算用到了broadcast，头一次看到将数据分发出去-_-bb。然后就在各自本地机器上计算。给定一个矩阵x，他的列向量的Gramian矩阵其实就是x’<em>x，他的行向量的Gramian矩阵就是x</em>x’。</p>
<pre><code><span class="keyword">private</span>[mllib] <span class="class"><span class="keyword">object</span> <span class="title">EigenValueDecomposition</span> {</span>
  <span class="comment">/**
   * Compute the leading k eigenvalues and eigenvectors on a symmetric square matrix using ARPACK.
   * The caller needs to ensure that the input matrix is real symmetric. This function requires
   * memory for `n*(4*k+4)` doubles.
   *
   * @param mul a function that multiplies the symmetric matrix with a DenseVector.
   * @param n dimension of the square matrix (maximum Int.MaxValue).
   * @param k number of leading eigenvalues required, 0 &lt; k &lt; n.
   * @param tol tolerance of the eigs computation.
   * @param maxIterations the maximum number of Arnoldi update iterations.
   * @return a dense vector of eigenvalues in descending order and a dense matrix of eigenvectors
   *         (columns of the matrix).
   * @note The number of computed eigenvalues might be smaller than k when some Ritz values do not
   *       satisfy the convergence criterion specified by tol (see ARPACK Users Guide, Chapter 4.6
   *       for more details). The maximum number of Arnoldi update iterations is set to 300 in this
   *       function.
   */</span>
  <span class="keyword">private</span>[mllib] <span class="function"><span class="keyword">def</span> <span class="title">symmetricEigs</span>(</span>
      mul: <span class="type">BDV</span>[<span class="type">Double</span>] =&gt; <span class="type">BDV</span>[<span class="type">Double</span>],
      n: <span class="type">Int</span>,
      k: <span class="type">Int</span>,
      tol: <span class="type">Double</span>,
      maxIterations: <span class="type">Int</span>): (<span class="type">BDV</span>[<span class="type">Double</span>], <span class="type">BDM</span>[<span class="type">Double</span>]) = {
    <span class="comment">// TODO: remove this function and use eigs in breeze when switching breeze version</span>
    require(n &gt; k, s<span class="string">"Number of required eigenvalues $k must be smaller than matrix dimension $n"</span>)

    <span class="function"><span class="keyword">val</span> <span class="title">arpack</span> =</span> <span class="type">ARPACK</span>.getInstance()

    <span class="comment">// tolerance used in stopping criterion</span>
    <span class="function"><span class="keyword">val</span> <span class="title">tolW</span> =</span> <span class="keyword">new</span> doubleW(tol)
    <span class="comment">// number of desired eigenvalues, 0 &lt; nev &lt; n</span>
    <span class="function"><span class="keyword">val</span> <span class="title">nev</span> =</span> <span class="keyword">new</span> intW(k)
    <span class="comment">// nev Lanczos vectors are generated in the first iteration</span>
    <span class="comment">// ncv-nev Lanczos vectors are generated in each subsequent iteration</span>
    <span class="comment">// ncv must be smaller than n</span>
    <span class="function"><span class="keyword">val</span> <span class="title">ncv</span> =</span> math.min(<span class="number">2</span> * k, n)

    <span class="comment">// "I" for standard eigenvalue problem, "G" for generalized eigenvalue problem</span>
    <span class="function"><span class="keyword">val</span> <span class="title">bmat</span> =</span> <span class="string">"I"</span>
    <span class="comment">// "LM" : compute the NEV largest (in magnitude) eigenvalues</span>
    <span class="function"><span class="keyword">val</span> <span class="title">which</span> =</span> <span class="string">"LM"</span>

    <span class="keyword">var</span> iparam = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">11</span>)
    <span class="comment">// use exact shift in each iteration</span>
    iparam(<span class="number">0</span>) = <span class="number">1</span>
    <span class="comment">// maximum number of Arnoldi update iterations, or the actual number of iterations on output</span>
    iparam(<span class="number">2</span>) = maxIterations
    <span class="comment">// Mode 1: A*x = lambda*x, A symmetric</span>
    iparam(<span class="number">6</span>) = <span class="number">1</span>

    require(n * ncv.toLong &lt;= <span class="type">Integer</span>.<span class="type">MAX_VALUE</span> &amp;&amp; ncv * (ncv.toLong + <span class="number">8</span>) &lt;= <span class="type">Integer</span>.<span class="type">MAX_VALUE</span>,
      s<span class="string">"k = $k and/or n = $n are too large to compute an eigendecomposition"</span>)

    <span class="keyword">var</span> ido = <span class="keyword">new</span> intW(<span class="number">0</span>)
    <span class="keyword">var</span> info = <span class="keyword">new</span> intW(<span class="number">0</span>)
    <span class="keyword">var</span> resid = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Double</span>](n)
    <span class="keyword">var</span> v = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Double</span>](n * ncv)
    <span class="keyword">var</span> workd = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Double</span>](n * <span class="number">3</span>)
    <span class="keyword">var</span> workl = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Double</span>](ncv * (ncv + <span class="number">8</span>))
    <span class="keyword">var</span> ipntr = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">11</span>)

    <span class="comment">// call ARPACK's reverse communication, first iteration with ido = 0</span>
    arpack.dsaupd(ido, bmat, n, which, nev.`<span class="function"><span class="keyword">val</span>`, <span class="title">tolW</span>, <span class="title">resid</span>, <span class="title">ncv</span>, <span class="title">v</span>, <span class="title">n</span>, <span class="title">iparam</span>, <span class="title">ipntr</span>, <span class="title">workd</span>,
</span>      workl, workl.length, info)

    <span class="function"><span class="keyword">val</span> <span class="title">w</span> =</span> <span class="type">BDV</span>(workd)

    <span class="comment">// ido = 99 : done flag in reverse communication</span>
    <span class="keyword">while</span> (ido.`<span class="function"><span class="keyword">val</span>` <span class="title">!=</span> 99) {</span>
      <span class="keyword">if</span> (ido.`<span class="function"><span class="keyword">val</span>` <span class="title">!=</span> <span class="title">-1</span> <span class="title">&amp;&amp;</span> <span class="title">ido</span>.`<span class="title">val</span>` <span class="title">!=</span> 1) {</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"ARPACK returns ido = "</span> + ido.`<span class="function"><span class="keyword">val</span>` <span class="title">+</span>
</span>            <span class="string">" This flag is not compatible with Mode 1: A*x = lambda*x, A symmetric."</span>)
      }
      <span class="comment">// multiply working vector with the matrix</span>
      <span class="function"><span class="keyword">val</span> <span class="title">inputOffset</span> =</span> ipntr(<span class="number">0</span>) - <span class="number">1</span>
      <span class="function"><span class="keyword">val</span> <span class="title">outputOffset</span> =</span> ipntr(<span class="number">1</span>) - <span class="number">1</span>
      <span class="function"><span class="keyword">val</span> <span class="title">x</span> =</span> w.slice(inputOffset, inputOffset + n)
      <span class="function"><span class="keyword">val</span> <span class="title">y</span> =</span> w.slice(outputOffset, outputOffset + n)
      y := mul(x)
      <span class="comment">// call ARPACK's reverse communication</span>
      arpack.dsaupd(ido, bmat, n, which, nev.`<span class="function"><span class="keyword">val</span>`, <span class="title">tolW</span>, <span class="title">resid</span>, <span class="title">ncv</span>, <span class="title">v</span>, <span class="title">n</span>, <span class="title">iparam</span>, <span class="title">ipntr</span>,
</span>        workd, workl, workl.length, info)
    }

    <span class="keyword">if</span> (info.`<span class="function"><span class="keyword">val</span>` <span class="title">!=</span> 0) {</span>
      info.`<span class="function"><span class="keyword">val</span>` <span class="title">match</span> {</span>
        <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"ARPACK returns non-zero info = "</span> + info.`<span class="function"><span class="keyword">val</span>` <span class="title">+</span>
</span>            <span class="string">" Maximum number of iterations taken. (Refer ARPACK user guide for details)"</span>)
        <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"ARPACK returns non-zero info = "</span> + info.`<span class="function"><span class="keyword">val</span>` <span class="title">+</span>
</span>            <span class="string">" No shifts could be applied. Try to increase NCV. "</span> +
            <span class="string">"(Refer ARPACK user guide for details)"</span>)
        <span class="keyword">case</span> _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"ARPACK returns non-zero info = "</span> + info.`<span class="function"><span class="keyword">val</span>` <span class="title">+</span>
</span>            <span class="string">" Please refer ARPACK user guide for error message."</span>)
      }
    }

    <span class="function"><span class="keyword">val</span> <span class="title">d</span> =</span> <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Double</span>](nev.`<span class="function"><span class="keyword">val</span>`)
</span>    <span class="function"><span class="keyword">val</span> <span class="title">select</span> =</span> <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Boolean</span>](ncv)
    <span class="comment">// copy the Ritz vectors</span>
    <span class="function"><span class="keyword">val</span> <span class="title">z</span> =</span> java.util.<span class="type">Arrays</span>.copyOfRange(v, <span class="number">0</span>, nev.`<span class="function"><span class="keyword">val</span>` <span class="title">*</span> <span class="title">n</span>)
</span>
    <span class="comment">// call ARPACK's post-processing for eigenvectors</span>
    arpack.dseupd(<span class="literal">true</span>, <span class="string">"A"</span>, select, d, z, n, <span class="number">0.0</span>, bmat, n, which, nev, tol, resid, ncv, v, n,
      iparam, ipntr, workd, workl, workl.length, info)

    <span class="comment">// number of computed eigenvalues, might be smaller than k</span>
    <span class="function"><span class="keyword">val</span> <span class="title">computed</span> =</span> iparam(<span class="number">4</span>)

    <span class="function"><span class="keyword">val</span> <span class="title">eigenPairs</span> =</span> java.util.<span class="type">Arrays</span>.copyOfRange(d, <span class="number">0</span>, computed).zipWithIndex.map { r =&gt;
      (r._1, java.util.<span class="type">Arrays</span>.copyOfRange(z, r._2 * n, r._2 * n + n))
    }

    <span class="comment">// sort the eigen-pairs in descending order</span>
    <span class="function"><span class="keyword">val</span> <span class="title">sortedEigenPairs</span> =</span> eigenPairs.sortBy(- _._1)

    <span class="comment">// copy eigenvectors in descending order of eigenvalues</span>
    <span class="function"><span class="keyword">val</span> <span class="title">sortedU</span> =</span> <span class="type">BDM</span>.zeros[<span class="type">Double</span>](n, computed)
    sortedEigenPairs.zipWithIndex.foreach { r =&gt;
      <span class="function"><span class="keyword">val</span> <span class="title">b</span> =</span> r._2 * n
      <span class="keyword">var</span> i = <span class="number">0</span>
      <span class="keyword">while</span> (i &lt; n) {
        sortedU.data(b + i) = r._1._2(i)
        i += <span class="number">1</span>
      }
    }

    (<span class="type">BDV</span>[<span class="type">Double</span>](sortedEigenPairs.map(_._1)), sortedU)
  }
}
</code></pre><p>最后来到关键的地方，所以其实spark内部的分布式求矩阵都是用svd的近似，不断调用Gramian方法来传递向量，用迭代的方式来求特征值和特征向量。最后返回的也是一个BDV，也就是breeze.linalg.DenseVector。我个人认为这种方法相比mpi，似乎一路上也没有checkpoint，效率可能还不一定比mpi做的高，毕竟MPI，BLAS，SCALAPACK这些库都是久经考验得工业标准了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/21/explore-spark-distributed-mllib/" data-id="cicfw51r3001sqtv42wa93d5d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mllib/">mllib</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spark/">spark</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/RDD/">RDD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/benchmark/">benchmark</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/">blog</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cnblogs/">cnblogs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cython/">cython</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dataframe/">dataframe</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/f2py/">f2py</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/migrate/">migrate</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mllib/">mllib</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/numba/">numba</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/numpy/">numpy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pyspark/">pyspark</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rdd/">rdd</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rust/">rust</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala/">scala</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scheduler/">scheduler</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/task/">task</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/RDD/" style="font-size: 10px;">RDD</a><a href="/tags/benchmark/" style="font-size: 10px;">benchmark</a><a href="/tags/blog/" style="font-size: 12px;">blog</a><a href="/tags/cnblogs/" style="font-size: 10px;">cnblogs</a><a href="/tags/cython/" style="font-size: 10px;">cython</a><a href="/tags/dataframe/" style="font-size: 10px;">dataframe</a><a href="/tags/f2py/" style="font-size: 10px;">f2py</a><a href="/tags/github/" style="font-size: 10px;">github</a><a href="/tags/hexo/" style="font-size: 12px;">hexo</a><a href="/tags/migrate/" style="font-size: 10px;">migrate</a><a href="/tags/mllib/" style="font-size: 12px;">mllib</a><a href="/tags/numba/" style="font-size: 10px;">numba</a><a href="/tags/numpy/" style="font-size: 10px;">numpy</a><a href="/tags/pyspark/" style="font-size: 10px;">pyspark</a><a href="/tags/python/" style="font-size: 16px;">python</a><a href="/tags/rdd/" style="font-size: 10px;">rdd</a><a href="/tags/rust/" style="font-size: 20px;">rust</a><a href="/tags/scala/" style="font-size: 14px;">scala</a><a href="/tags/scheduler/" style="font-size: 10px;">scheduler</a><a href="/tags/spark/" style="font-size: 18px;">spark</a><a href="/tags/task/" style="font-size: 10px;">task</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">June 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/04/">April 2012</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">March 2012</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/01/">January 2012</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/07/23/learning-rust-part-IX/">rust学习笔记(九)</a>
          </li>
        
          <li>
            <a href="/2015/07/21/learning-rust-part-VIII/">rust学习笔记(八)</a>
          </li>
        
          <li>
            <a href="/2015/07/21/learning-rust-part-VII/">rust学习笔记(七)</a>
          </li>
        
          <li>
            <a href="/2015/07/21/learning-rust-part-VI/">rust学习笔记(六)</a>
          </li>
        
          <li>
            <a href="/2015/07/20/learning-rust-part-V/">rust学习笔记(五)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Yuankun Shi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/index.html" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>